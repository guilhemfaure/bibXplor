{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/sort.js","filenameRelative":"/packages/minimongo/sort.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/sort.js.map","sourceFileName":"/packages/minimongo/sort.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"sort"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\nMinimongo.Sorter = function (spec, options) {\n  var self = this;\n  options = options || {};\n  self._sortSpecParts = [];\n  self._sortFunction = null;\n\n  var addSpecPart = function (path, ascending) {\n    if (!path) throw Error(\"sort keys must be non-empty\");\n    if (path.charAt(0) === '$') throw Error(\"unsupported sort key: \" + path);\n\n    self._sortSpecParts.push({\n      path: path,\n      lookup: makeLookupFunction(path, {\n        forSort: true\n      }),\n      ascending: ascending\n    });\n  };\n\n  if (spec instanceof Array) {\n    for (var i = 0; i < spec.length; i++) {\n      if (typeof spec[i] === \"string\") {\n        addSpecPart(spec[i], true);\n      } else {\n        addSpecPart(spec[i][0], spec[i][1] !== \"desc\");\n      }\n    }\n  } else if ((typeof spec === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(spec)) === \"object\") {\n    _.each(spec, function (value, key) {\n      addSpecPart(key, value >= 0);\n    });\n  } else if (typeof spec === \"function\") {\n    self._sortFunction = spec;\n  } else {\n    throw Error(\"Bad sort specification: \" + JSON.stringify(spec));\n  } // If a function is specified for sorting, we skip the rest.\n\n\n  if (self._sortFunction) return; // To implement affectedByModifier, we piggy-back on top of Matcher's\n  // affectedByModifier code; we create a selector that is affected by the same\n  // modifiers as this sort order. This is only implemented on the server.\n\n  if (self.affectedByModifier) {\n    var selector = {};\n\n    _.each(self._sortSpecParts, function (spec) {\n      selector[spec.path] = 1;\n    });\n\n    self._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n  }\n\n  self._keyComparator = composeComparators(_.map(self._sortSpecParts, function (spec, i) {\n    return self._keyFieldComparator(i);\n  })); // If you specify a matcher for this Sorter, _keyFilter may be set to a\n  // function which selects whether or not a given \"sort key\" (tuple of values\n  // for the different sort spec fields) is compatible with the selector.\n\n  self._keyFilter = null;\n  options.matcher && self._useWithMatcher(options.matcher);\n}; // In addition to these methods, sorter_project.js defines combineIntoProjection\n// on the server only.\n\n\n_.extend(Minimongo.Sorter.prototype, {\n  getComparator: function (options) {\n    var self = this; // If we have no distances, just use the comparator from the source\n    // specification (which defaults to \"everything is equal\".\n\n    if (!options || !options.distances) {\n      return self._getBaseComparator();\n    }\n\n    var distances = options.distances; // Return a comparator which first tries the sort specification, and if that\n    // says \"it's equal\", breaks ties using $near distances.\n\n    return composeComparators([self._getBaseComparator(), function (a, b) {\n      if (!distances.has(a._id)) throw Error(\"Missing distance for \" + a._id);\n      if (!distances.has(b._id)) throw Error(\"Missing distance for \" + b._id);\n      return distances.get(a._id) - distances.get(b._id);\n    }]);\n  },\n  _getPaths: function () {\n    var self = this;\n    return _.pluck(self._sortSpecParts, 'path');\n  },\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc: function (doc) {\n    var self = this;\n    var minKey = null;\n\n    self._generateKeysFromDoc(doc, function (key) {\n      if (!self._keyCompatibleWithSelector(key)) return;\n\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n\n      if (self._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    }); // This could happen if our key filter somehow filters out all the keys even\n    // though somehow the selector matches.\n\n\n    if (minKey === null) throw Error(\"sort selector found no keys in doc?\");\n    return minKey;\n  },\n  _keyCompatibleWithSelector: function (key) {\n    var self = this;\n    return !self._keyFilter || self._keyFilter(key);\n  },\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc: function (doc, cb) {\n    var self = this;\n    if (self._sortSpecParts.length === 0) throw new Error(\"can't generate keys without a spec\"); // maps index -> ({'' -> value} or {path -> value})\n\n    var valuesByIndexAndPath = [];\n\n    var pathFromIndices = function (indices) {\n      return indices.join(',') + ',';\n    };\n\n    var knownPaths = null;\n\n    _.each(self._sortSpecParts, function (spec, whichField) {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      var branches = expandArraysInBranches(spec.lookup(doc), true); // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one null value.\n\n      if (!branches.length) branches = [{\n        value: null\n      }];\n      var usedPaths = false;\n      valuesByIndexAndPath[whichField] = {};\n\n      _.each(branches, function (branch) {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1) throw Error(\"multiple branches but no array used?\");\n          valuesByIndexAndPath[whichField][''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n        var path = pathFromIndices(branch.arrayIndices);\n        if (_.has(valuesByIndexAndPath[whichField], path)) throw Error(\"duplicate path: \" + path);\n        valuesByIndexAndPath[whichField][path] = branch.value; // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n\n        if (knownPaths && !_.has(knownPaths, path)) {\n          throw Error(\"cannot index parallel arrays\");\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!_.has(valuesByIndexAndPath[whichField], '') && _.size(knownPaths) !== _.size(valuesByIndexAndPath[whichField])) {\n          throw Error(\"cannot index parallel arrays!\");\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n\n        _.each(valuesByIndexAndPath[whichField], function (x, path) {\n          knownPaths[path] = true;\n        });\n      }\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      var soleKey = _.map(valuesByIndexAndPath, function (values) {\n        if (!_.has(values, '')) throw Error(\"no value in sole key case?\");\n        return values[''];\n      });\n\n      cb(soleKey);\n      return;\n    }\n\n    _.each(knownPaths, function (x, path) {\n      var key = _.map(valuesByIndexAndPath, function (values) {\n        if (_.has(values, '')) return values[''];\n        if (!_.has(values, path)) throw Error(\"missing path?\");\n        return values[path];\n      });\n\n      cb(key);\n    });\n  },\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys: function (key1, key2) {\n    var self = this;\n\n    if (key1.length !== self._sortSpecParts.length || key2.length !== self._sortSpecParts.length) {\n      throw Error(\"Key has wrong length\");\n    }\n\n    return self._keyComparator(key1, key2);\n  },\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator: function (i) {\n    var self = this;\n    var invert = !self._sortSpecParts[i].ascending;\n    return function (key1, key2) {\n      var compare = LocalCollection._f._cmp(key1[i], key2[i]);\n\n      if (invert) compare = -compare;\n      return compare;\n    };\n  },\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator: function () {\n    var self = this;\n    if (self._sortFunction) return self._sortFunction; // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n\n    if (!self._sortSpecParts.length) {\n      return function (doc1, doc2) {\n        return 0;\n      };\n    }\n\n    return function (doc1, doc2) {\n      var key1 = self._getMinKeyFromDoc(doc1);\n\n      var key2 = self._getMinKeyFromDoc(doc2);\n\n      return self._compareKeys(key1, key2);\n    };\n  },\n  // In MongoDB, if you have documents\n  //    {_id: 'x', a: [1, 10]} and\n  //    {_id: 'y', a: [5, 15]},\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n  // match the selector, and 5 comes before 10).\n  //\n  // The way this works is pretty subtle!  For example, if the documents\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n  // both follow this rule (y before x).  (ie, you do have to apply this\n  // through $elemMatch.)\n  //\n  // So if you pass a matcher to this sorter's constructor, we will attempt to\n  // skip sort keys that don't match the selector. The logic here is pretty\n  // subtle and undocumented; we've gotten as close as we can figure out based\n  // on our understanding of Mongo's behavior.\n  _useWithMatcher: function (matcher) {\n    var self = this;\n    if (self._keyFilter) throw Error(\"called _useWithMatcher twice?\"); // If we are only sorting by distance, then we're not going to bother to\n    // build a key filter.\n    // XXX figure out how geoqueries interact with this stuff\n\n    if (_.isEmpty(self._sortSpecParts)) return;\n    var selector = matcher._selector; // If the user just passed a literal function to find(), then we can't get a\n    // key filter from it.\n\n    if (selector instanceof Function) return;\n    var constraintsByPath = {};\n\n    _.each(self._sortSpecParts, function (spec, i) {\n      constraintsByPath[spec.path] = [];\n    });\n\n    _.each(selector, function (subSelector, key) {\n      // XXX support $and and $or\n      var constraints = constraintsByPath[key];\n      if (!constraints) return; // XXX it looks like the real MongoDB implementation isn't \"does the\n      // regexp match\" but \"does the value fall into a range named by the\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But\n      // \"does the regexp match\" is a good approximation.\n\n      if (subSelector instanceof RegExp) {\n        // As far as we can tell, using either of the options that both we and\n        // MongoDB support ('i' and 'm') disables use of the key filter. This\n        // makes sense: MongoDB mostly appears to be calculating ranges of an\n        // index to use, which means it only cares about regexps that match\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the\n        // literal prefix of the regexp from actually meaning one range.\n        if (subSelector.ignoreCase || subSelector.multiline) return;\n        constraints.push(regexpElementMatcher(subSelector));\n        return;\n      }\n\n      if (isOperatorObject(subSelector)) {\n        _.each(subSelector, function (operand, operator) {\n          if (_.contains(['$lt', '$lte', '$gt', '$gte'], operator)) {\n            // XXX this depends on us knowing that these operators don't use any\n            // of the arguments to compileElementSelector other than operand.\n            constraints.push(ELEMENT_OPERATORS[operator].compileElementSelector(operand));\n          } // See comments in the RegExp block above.\n\n\n          if (operator === '$regex' && !subSelector.$options) {\n            constraints.push(ELEMENT_OPERATORS.$regex.compileElementSelector(operand, subSelector));\n          } // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n\n        });\n\n        return;\n      } // OK, it's an equality thing.\n\n\n      constraints.push(equalityElementMatcher(subSelector));\n    }); // It appears that the first sort field is treated differently from the\n    // others; we shouldn't create a key filter unless the first sort field is\n    // restricted, though after that point we can restrict the other sort fields\n    // or not as we wish.\n\n\n    if (_.isEmpty(constraintsByPath[self._sortSpecParts[0].path])) return;\n\n    self._keyFilter = function (key) {\n      return _.all(self._sortSpecParts, function (specPart, index) {\n        return _.all(constraintsByPath[specPart.path], function (f) {\n          return f(key[index]);\n        });\n      });\n    };\n  }\n}); // Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\n\n\nvar composeComparators = function (comparatorArray) {\n  return function (a, b) {\n    for (var i = 0; i < comparatorArray.length; ++i) {\n      var compare = comparatorArray[i](a, b);\n      if (compare !== 0) return compare;\n    }\n\n    return 0;\n  };\n};","map":{"version":3,"sources":["/packages/minimongo/sort.js"],"names":["Minimongo","Sorter","spec","options","self","_sortSpecParts","_sortFunction","addSpecPart","path","ascending","Error","charAt","push","lookup","makeLookupFunction","forSort","Array","i","length","_","each","value","key","JSON","stringify","affectedByModifier","selector","_selectorForAffectedByModifier","Matcher","_keyComparator","composeComparators","map","_keyFieldComparator","_keyFilter","matcher","_useWithMatcher","extend","prototype","getComparator","distances","_getBaseComparator","a","b","has","_id","get","_getPaths","pluck","_getMinKeyFromDoc","doc","minKey","_generateKeysFromDoc","_keyCompatibleWithSelector","_compareKeys","cb","valuesByIndexAndPath","pathFromIndices","indices","join","knownPaths","whichField","branches","expandArraysInBranches","usedPaths","branch","arrayIndices","size","x","soleKey","values","key1","key2","invert","compare","LocalCollection","_f","_cmp","doc1","doc2","isEmpty","_selector","Function","constraintsByPath","subSelector","constraints","RegExp","ignoreCase","multiline","regexpElementMatcher","isOperatorObject","operand","operator","contains","ELEMENT_OPERATORS","compileElementSelector","$options","$regex","equalityElementMatcher","all","specPart","index","f","comparatorArray"],"mappings":"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","file":"/packages/minimongo/sort.js.map","sourcesContent":["// Give a sort spec, which can be in any of these forms:\n//   {\"key1\": 1, \"key2\": -1}\n//   [[\"key1\", \"asc\"], [\"key2\", \"desc\"]]\n//   [\"key1\", [\"key2\", \"desc\"]]\n//\n// (.. with the first form being dependent on the key enumeration\n// behavior of your javascript VM, which usually does what you mean in\n// this case if the key names don't look like integers ..)\n//\n// return a function that takes two objects, and returns -1 if the\n// first object comes first in order, 1 if the second object comes\n// first, or 0 if neither object comes before the other.\n\nMinimongo.Sorter = function (spec, options) {\n  var self = this;\n  options = options || {};\n\n  self._sortSpecParts = [];\n  self._sortFunction = null;\n\n  var addSpecPart = function (path, ascending) {\n    if (!path)\n      throw Error(\"sort keys must be non-empty\");\n    if (path.charAt(0) === '$')\n      throw Error(\"unsupported sort key: \" + path);\n    self._sortSpecParts.push({\n      path: path,\n      lookup: makeLookupFunction(path, {forSort: true}),\n      ascending: ascending\n    });\n  };\n\n  if (spec instanceof Array) {\n    for (var i = 0; i < spec.length; i++) {\n      if (typeof spec[i] === \"string\") {\n        addSpecPart(spec[i], true);\n      } else {\n        addSpecPart(spec[i][0], spec[i][1] !== \"desc\");\n      }\n    }\n  } else if (typeof spec === \"object\") {\n    _.each(spec, function (value, key) {\n      addSpecPart(key, value >= 0);\n    });\n  } else if (typeof spec === \"function\") {\n    self._sortFunction = spec;\n  } else {\n    throw Error(\"Bad sort specification: \" + JSON.stringify(spec));\n  }\n\n  // If a function is specified for sorting, we skip the rest.\n  if (self._sortFunction)\n    return;\n\n  // To implement affectedByModifier, we piggy-back on top of Matcher's\n  // affectedByModifier code; we create a selector that is affected by the same\n  // modifiers as this sort order. This is only implemented on the server.\n  if (self.affectedByModifier) {\n    var selector = {};\n    _.each(self._sortSpecParts, function (spec) {\n      selector[spec.path] = 1;\n    });\n    self._selectorForAffectedByModifier = new Minimongo.Matcher(selector);\n  }\n\n  self._keyComparator = composeComparators(\n    _.map(self._sortSpecParts, function (spec, i) {\n      return self._keyFieldComparator(i);\n    }));\n\n  // If you specify a matcher for this Sorter, _keyFilter may be set to a\n  // function which selects whether or not a given \"sort key\" (tuple of values\n  // for the different sort spec fields) is compatible with the selector.\n  self._keyFilter = null;\n  options.matcher && self._useWithMatcher(options.matcher);\n};\n\n// In addition to these methods, sorter_project.js defines combineIntoProjection\n// on the server only.\n_.extend(Minimongo.Sorter.prototype, {\n  getComparator: function (options) {\n    var self = this;\n\n    // If we have no distances, just use the comparator from the source\n    // specification (which defaults to \"everything is equal\".\n    if (!options || !options.distances) {\n      return self._getBaseComparator();\n    }\n\n    var distances = options.distances;\n\n    // Return a comparator which first tries the sort specification, and if that\n    // says \"it's equal\", breaks ties using $near distances.\n    return composeComparators([self._getBaseComparator(), function (a, b) {\n      if (!distances.has(a._id))\n        throw Error(\"Missing distance for \" + a._id);\n      if (!distances.has(b._id))\n        throw Error(\"Missing distance for \" + b._id);\n      return distances.get(a._id) - distances.get(b._id);\n    }]);\n  },\n\n  _getPaths: function () {\n    var self = this;\n    return _.pluck(self._sortSpecParts, 'path');\n  },\n\n  // Finds the minimum key from the doc, according to the sort specs.  (We say\n  // \"minimum\" here but this is with respect to the sort spec, so \"descending\"\n  // sort fields mean we're finding the max for that field.)\n  //\n  // Note that this is NOT \"find the minimum value of the first field, the\n  // minimum value of the second field, etc\"... it's \"choose the\n  // lexicographically minimum value of the key vector, allowing only keys which\n  // you can find along the same paths\".  ie, for a doc {a: [{x: 0, y: 5}, {x:\n  // 1, y: 3}]} with sort spec {'a.x': 1, 'a.y': 1}, the only keys are [0,5] and\n  // [1,3], and the minimum key is [0,5]; notably, [0,3] is NOT a key.\n  _getMinKeyFromDoc: function (doc) {\n    var self = this;\n    var minKey = null;\n\n    self._generateKeysFromDoc(doc, function (key) {\n      if (!self._keyCompatibleWithSelector(key))\n        return;\n\n      if (minKey === null) {\n        minKey = key;\n        return;\n      }\n      if (self._compareKeys(key, minKey) < 0) {\n        minKey = key;\n      }\n    });\n\n    // This could happen if our key filter somehow filters out all the keys even\n    // though somehow the selector matches.\n    if (minKey === null)\n      throw Error(\"sort selector found no keys in doc?\");\n    return minKey;\n  },\n\n  _keyCompatibleWithSelector: function (key) {\n    var self = this;\n    return !self._keyFilter || self._keyFilter(key);\n  },\n\n  // Iterates over each possible \"key\" from doc (ie, over each branch), calling\n  // 'cb' with the key.\n  _generateKeysFromDoc: function (doc, cb) {\n    var self = this;\n\n    if (self._sortSpecParts.length === 0)\n      throw new Error(\"can't generate keys without a spec\");\n\n    // maps index -> ({'' -> value} or {path -> value})\n    var valuesByIndexAndPath = [];\n\n    var pathFromIndices = function (indices) {\n      return indices.join(',') + ',';\n    };\n\n    var knownPaths = null;\n\n    _.each(self._sortSpecParts, function (spec, whichField) {\n      // Expand any leaf arrays that we find, and ignore those arrays\n      // themselves.  (We never sort based on an array itself.)\n      var branches = expandArraysInBranches(spec.lookup(doc), true);\n\n      // If there are no values for a key (eg, key goes to an empty array),\n      // pretend we found one null value.\n      if (!branches.length)\n        branches = [{value: null}];\n\n      var usedPaths = false;\n      valuesByIndexAndPath[whichField] = {};\n      _.each(branches, function (branch) {\n        if (!branch.arrayIndices) {\n          // If there are no array indices for a branch, then it must be the\n          // only branch, because the only thing that produces multiple branches\n          // is the use of arrays.\n          if (branches.length > 1)\n            throw Error(\"multiple branches but no array used?\");\n          valuesByIndexAndPath[whichField][''] = branch.value;\n          return;\n        }\n\n        usedPaths = true;\n        var path = pathFromIndices(branch.arrayIndices);\n        if (_.has(valuesByIndexAndPath[whichField], path))\n          throw Error(\"duplicate path: \" + path);\n        valuesByIndexAndPath[whichField][path] = branch.value;\n\n        // If two sort fields both go into arrays, they have to go into the\n        // exact same arrays and we have to find the same paths.  This is\n        // roughly the same condition that makes MongoDB throw this strange\n        // error message.  eg, the main thing is that if sort spec is {a: 1,\n        // b:1} then a and b cannot both be arrays.\n        //\n        // (In MongoDB it seems to be OK to have {a: 1, 'a.x.y': 1} where 'a'\n        // and 'a.x.y' are both arrays, but we don't allow this for now.\n        // #NestedArraySort\n        // XXX achieve full compatibility here\n        if (knownPaths && !_.has(knownPaths, path)) {\n          throw Error(\"cannot index parallel arrays\");\n        }\n      });\n\n      if (knownPaths) {\n        // Similarly to above, paths must match everywhere, unless this is a\n        // non-array field.\n        if (!_.has(valuesByIndexAndPath[whichField], '') &&\n            _.size(knownPaths) !== _.size(valuesByIndexAndPath[whichField])) {\n          throw Error(\"cannot index parallel arrays!\");\n        }\n      } else if (usedPaths) {\n        knownPaths = {};\n        _.each(valuesByIndexAndPath[whichField], function (x, path) {\n          knownPaths[path] = true;\n        });\n      }\n    });\n\n    if (!knownPaths) {\n      // Easy case: no use of arrays.\n      var soleKey = _.map(valuesByIndexAndPath, function (values) {\n        if (!_.has(values, ''))\n          throw Error(\"no value in sole key case?\");\n        return values[''];\n      });\n      cb(soleKey);\n      return;\n    }\n\n    _.each(knownPaths, function (x, path) {\n      var key = _.map(valuesByIndexAndPath, function (values) {\n        if (_.has(values, ''))\n          return values[''];\n        if (!_.has(values, path))\n          throw Error(\"missing path?\");\n        return values[path];\n      });\n      cb(key);\n    });\n  },\n\n  // Takes in two keys: arrays whose lengths match the number of spec\n  // parts. Returns negative, 0, or positive based on using the sort spec to\n  // compare fields.\n  _compareKeys: function (key1, key2) {\n    var self = this;\n    if (key1.length !== self._sortSpecParts.length ||\n        key2.length !== self._sortSpecParts.length) {\n      throw Error(\"Key has wrong length\");\n    }\n\n    return self._keyComparator(key1, key2);\n  },\n\n  // Given an index 'i', returns a comparator that compares two key arrays based\n  // on field 'i'.\n  _keyFieldComparator: function (i) {\n    var self = this;\n    var invert = !self._sortSpecParts[i].ascending;\n    return function (key1, key2) {\n      var compare = LocalCollection._f._cmp(key1[i], key2[i]);\n      if (invert)\n        compare = -compare;\n      return compare;\n    };\n  },\n\n  // Returns a comparator that represents the sort specification (but not\n  // including a possible geoquery distance tie-breaker).\n  _getBaseComparator: function () {\n    var self = this;\n\n    if (self._sortFunction)\n      return self._sortFunction;\n\n    // If we're only sorting on geoquery distance and no specs, just say\n    // everything is equal.\n    if (!self._sortSpecParts.length) {\n      return function (doc1, doc2) {\n        return 0;\n      };\n    }\n\n    return function (doc1, doc2) {\n      var key1 = self._getMinKeyFromDoc(doc1);\n      var key2 = self._getMinKeyFromDoc(doc2);\n      return self._compareKeys(key1, key2);\n    };\n  },\n\n  // In MongoDB, if you have documents\n  //    {_id: 'x', a: [1, 10]} and\n  //    {_id: 'y', a: [5, 15]},\n  // then C.find({}, {sort: {a: 1}}) puts x before y (1 comes before 5).\n  // But  C.find({a: {$gt: 3}}, {sort: {a: 1}}) puts y before x (1 does not\n  // match the selector, and 5 comes before 10).\n  //\n  // The way this works is pretty subtle!  For example, if the documents\n  // are instead {_id: 'x', a: [{x: 1}, {x: 10}]}) and\n  //             {_id: 'y', a: [{x: 5}, {x: 15}]}),\n  // then C.find({'a.x': {$gt: 3}}, {sort: {'a.x': 1}}) and\n  //      C.find({a: {$elemMatch: {x: {$gt: 3}}}}, {sort: {'a.x': 1}})\n  // both follow this rule (y before x).  (ie, you do have to apply this\n  // through $elemMatch.)\n  //\n  // So if you pass a matcher to this sorter's constructor, we will attempt to\n  // skip sort keys that don't match the selector. The logic here is pretty\n  // subtle and undocumented; we've gotten as close as we can figure out based\n  // on our understanding of Mongo's behavior.\n  _useWithMatcher: function (matcher) {\n    var self = this;\n\n    if (self._keyFilter)\n      throw Error(\"called _useWithMatcher twice?\");\n\n    // If we are only sorting by distance, then we're not going to bother to\n    // build a key filter.\n    // XXX figure out how geoqueries interact with this stuff\n    if (_.isEmpty(self._sortSpecParts))\n      return;\n\n    var selector = matcher._selector;\n\n    // If the user just passed a literal function to find(), then we can't get a\n    // key filter from it.\n    if (selector instanceof Function)\n      return;\n\n    var constraintsByPath = {};\n    _.each(self._sortSpecParts, function (spec, i) {\n      constraintsByPath[spec.path] = [];\n    });\n\n    _.each(selector, function (subSelector, key) {\n      // XXX support $and and $or\n\n      var constraints = constraintsByPath[key];\n      if (!constraints)\n        return;\n\n      // XXX it looks like the real MongoDB implementation isn't \"does the\n      // regexp match\" but \"does the value fall into a range named by the\n      // literal prefix of the regexp\", ie \"foo\" in /^foo(bar|baz)+/  But\n      // \"does the regexp match\" is a good approximation.\n      if (subSelector instanceof RegExp) {\n        // As far as we can tell, using either of the options that both we and\n        // MongoDB support ('i' and 'm') disables use of the key filter. This\n        // makes sense: MongoDB mostly appears to be calculating ranges of an\n        // index to use, which means it only cares about regexps that match\n        // one range (with a literal prefix), and both 'i' and 'm' prevent the\n        // literal prefix of the regexp from actually meaning one range.\n        if (subSelector.ignoreCase || subSelector.multiline)\n          return;\n        constraints.push(regexpElementMatcher(subSelector));\n        return;\n      }\n\n      if (isOperatorObject(subSelector)) {\n        _.each(subSelector, function (operand, operator) {\n          if (_.contains(['$lt', '$lte', '$gt', '$gte'], operator)) {\n            // XXX this depends on us knowing that these operators don't use any\n            // of the arguments to compileElementSelector other than operand.\n            constraints.push(\n              ELEMENT_OPERATORS[operator].compileElementSelector(operand));\n          }\n\n          // See comments in the RegExp block above.\n          if (operator === '$regex' && !subSelector.$options) {\n            constraints.push(\n              ELEMENT_OPERATORS.$regex.compileElementSelector(\n                operand, subSelector));\n          }\n\n          // XXX support {$exists: true}, $mod, $type, $in, $elemMatch\n        });\n        return;\n      }\n\n      // OK, it's an equality thing.\n      constraints.push(equalityElementMatcher(subSelector));\n    });\n\n    // It appears that the first sort field is treated differently from the\n    // others; we shouldn't create a key filter unless the first sort field is\n    // restricted, though after that point we can restrict the other sort fields\n    // or not as we wish.\n    if (_.isEmpty(constraintsByPath[self._sortSpecParts[0].path]))\n      return;\n\n    self._keyFilter = function (key) {\n      return _.all(self._sortSpecParts, function (specPart, index) {\n        return _.all(constraintsByPath[specPart.path], function (f) {\n          return f(key[index]);\n        });\n      });\n    };\n  }\n});\n\n// Given an array of comparators\n// (functions (a,b)->(negative or positive or zero)), returns a single\n// comparator which uses each comparator in order and returns the first\n// non-zero value.\nvar composeComparators = function (comparatorArray) {\n  return function (a, b) {\n    for (var i = 0; i < comparatorArray.length; ++i) {\n      var compare = comparatorArray[i](a, b);\n      if (compare !== 0)\n        return compare;\n    }\n    return 0;\n  };\n};\n"]},"hash":"e7a593a3e1adbf4c08ef56cbcd780dc6b81fdcea"}
