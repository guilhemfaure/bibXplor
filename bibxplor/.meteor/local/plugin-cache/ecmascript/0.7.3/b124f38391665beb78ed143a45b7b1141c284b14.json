{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/wrap_transform.js","filenameRelative":"/packages/minimongo/wrap_transform.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/wrap_transform.js.map","sourceFileName":"/packages/minimongo/wrap_transform.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"wrap_transform"},"ignored":false,"code":"// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = function (transform) {\n  if (!transform) return null; // No need to doubly-wrap transforms.\n\n  if (transform.__wrappedTransform__) return transform;\n\n  var wrapped = function (doc) {\n    if (!_.has(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error(\"can only transform documents with _id\");\n    }\n\n    var id = doc._id; // XXX consider making tracker a weak dependency and checking Package.tracker here\n\n    var transformed = Tracker.nonreactive(function () {\n      return transform(doc);\n    });\n\n    if (!isPlainObject(transformed)) {\n      throw new Error(\"transform must return object\");\n    }\n\n    if (_.has(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error(\"transformed document can't have different _id\");\n      }\n    } else {\n      transformed._id = id;\n    }\n\n    return transformed;\n  };\n\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n};","map":{"version":3,"sources":["/packages/minimongo/wrap_transform.js"],"names":["LocalCollection","wrapTransform","transform","__wrappedTransform__","wrapped","doc","_","has","Error","id","_id","transformed","Tracker","nonreactive","isPlainObject","EJSON","equals"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAA,gBAAgBC,aAAhB,GAAgC,UAAUC,SAAV,EAAqB;AACnD,MAAI,CAAEA,SAAN,EACE,OAAO,IAAP,CAFiD,CAInD;;AACA,MAAIA,UAAUC,oBAAd,EACE,OAAOD,SAAP;;AAEF,MAAIE,UAAU,UAAUC,GAAV,EAAe;AAC3B,QAAI,CAACC,EAAEC,GAAF,CAAMF,GAAN,EAAW,KAAX,CAAL,EAAwB;AACtB;AACA;AACA,YAAM,IAAIG,KAAJ,CAAU,uCAAV,CAAN;AACD;;AAED,QAAIC,KAAKJ,IAAIK,GAAb,CAP2B,CAQ3B;;AACA,QAAIC,cAAcC,QAAQC,WAAR,CAAoB,YAAY;AAChD,aAAOX,UAAUG,GAAV,CAAP;AACD,KAFiB,CAAlB;;AAIA,QAAI,CAACS,cAAcH,WAAd,CAAL,EAAiC;AAC/B,YAAM,IAAIH,KAAJ,CAAU,8BAAV,CAAN;AACD;;AAED,QAAIF,EAAEC,GAAF,CAAMI,WAAN,EAAmB,KAAnB,CAAJ,EAA+B;AAC7B,UAAI,CAACI,MAAMC,MAAN,CAAaL,YAAYD,GAAzB,EAA8BD,EAA9B,CAAL,EAAwC;AACtC,cAAM,IAAID,KAAJ,CAAU,+CAAV,CAAN;AACD;AACF,KAJD,MAIO;AACLG,kBAAYD,GAAZ,GAAkBD,EAAlB;AACD;;AACD,WAAOE,WAAP;AACD,GAzBD;;AA0BAP,UAAQD,oBAAR,GAA+B,IAA/B;AACA,SAAOC,OAAP;AACD,CApCD","file":"/packages/minimongo/wrap_transform.js.map","sourcesContent":["// Wrap a transform function to return objects that have the _id field\n// of the untransformed document. This ensures that subsystems such as\n// the observe-sequence package that call `observe` can keep track of\n// the documents identities.\n//\n// - Require that it returns objects\n// - If the return value has an _id field, verify that it matches the\n//   original _id field\n// - If the return value doesn't have an _id field, add it back.\nLocalCollection.wrapTransform = function (transform) {\n  if (! transform)\n    return null;\n\n  // No need to doubly-wrap transforms.\n  if (transform.__wrappedTransform__)\n    return transform;\n\n  var wrapped = function (doc) {\n    if (!_.has(doc, '_id')) {\n      // XXX do we ever have a transform on the oplog's collection? because that\n      // collection has no _id.\n      throw new Error(\"can only transform documents with _id\");\n    }\n\n    var id = doc._id;\n    // XXX consider making tracker a weak dependency and checking Package.tracker here\n    var transformed = Tracker.nonreactive(function () {\n      return transform(doc);\n    });\n\n    if (!isPlainObject(transformed)) {\n      throw new Error(\"transform must return object\");\n    }\n\n    if (_.has(transformed, '_id')) {\n      if (!EJSON.equals(transformed._id, id)) {\n        throw new Error(\"transformed document can't have different _id\");\n      }\n    } else {\n      transformed._id = id;\n    }\n    return transformed;\n  };\n  wrapped.__wrappedTransform__ = true;\n  return wrapped;\n};\n"]},"hash":"b124f38391665beb78ed143a45b7b1141c284b14"}
