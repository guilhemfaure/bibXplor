{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/observe.js","filenameRelative":"/packages/minimongo/observe.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/observe.js.map","sourceFileName":"/packages/minimongo/observe.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"observe"},"ignored":false,"code":"// XXX maybe move these into another ObserveHelpers package or something\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in self.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = function (options) {\n  var self = this;\n  options = options || {};\n\n  var orderedFromCallbacks = options.callbacks && LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n\n  if (_.has(options, 'ordered')) {\n    self.ordered = options.ordered;\n    if (options.callbacks && options.ordered !== orderedFromCallbacks) throw Error(\"ordered option doesn't match callbacks\");\n  } else if (options.callbacks) {\n    self.ordered = orderedFromCallbacks;\n  } else {\n    throw Error(\"must provide ordered or callbacks\");\n  }\n\n  var callbacks = options.callbacks || {};\n\n  if (self.ordered) {\n    self.docs = new OrderedDict(MongoID.idStringify);\n    self.applyChange = {\n      addedBefore: function (id, fields, before) {\n        var doc = EJSON.clone(fields);\n        doc._id = id;\n        callbacks.addedBefore && callbacks.addedBefore.call(self, id, fields, before); // This line triggers if we provide added with movedBefore.\n\n        callbacks.added && callbacks.added.call(self, id, fields); // XXX could `before` be a falsy ID?  Technically\n        // idStringify seems to allow for them -- though\n        // OrderedDict won't call stringify on a falsy arg.\n\n        self.docs.putBefore(id, doc, before || null);\n      },\n      movedBefore: function (id, before) {\n        var doc = self.docs.get(id);\n        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);\n        self.docs.moveBefore(id, before || null);\n      }\n    };\n  } else {\n    self.docs = new LocalCollection._IdMap();\n    self.applyChange = {\n      added: function (id, fields) {\n        var doc = EJSON.clone(fields);\n        callbacks.added && callbacks.added.call(self, id, fields);\n        doc._id = id;\n        self.docs.set(id, doc);\n      }\n    };\n  } // The methods in _IdMap and OrderedDict used by these callbacks are\n  // identical.\n\n\n  self.applyChange.changed = function (id, fields) {\n    var doc = self.docs.get(id);\n    if (!doc) throw new Error(\"Unknown id for changed: \" + id);\n    callbacks.changed && callbacks.changed.call(self, id, EJSON.clone(fields));\n    DiffSequence.applyChanges(doc, fields);\n  };\n\n  self.applyChange.removed = function (id) {\n    callbacks.removed && callbacks.removed.call(self, id);\n    self.docs.remove(id);\n  };\n};\n\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {\n  var transform = cursor.getTransform() || function (doc) {\n    return doc;\n  };\n\n  var suppressed = !!observeCallbacks._suppress_initial;\n  var observeChangesCallbacks;\n\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    var indices = !observeCallbacks._no_indices;\n    observeChangesCallbacks = {\n      addedBefore: function (id, fields, before) {\n        var self = this;\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added)) return;\n        var doc = transform(_.extend(fields, {\n          _id: id\n        }));\n\n        if (observeCallbacks.addedAt) {\n          var index = indices ? before ? self.docs.indexOf(before) : self.docs.size() : -1;\n          observeCallbacks.addedAt(doc, index, before);\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed: function (id, fields) {\n        var self = this;\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed)) return;\n        var doc = EJSON.clone(self.docs.get(id));\n        if (!doc) throw new Error(\"Unknown id for changed: \" + id);\n        var oldDoc = transform(EJSON.clone(doc));\n        DiffSequence.applyChanges(doc, fields);\n        doc = transform(doc);\n\n        if (observeCallbacks.changedAt) {\n          var index = indices ? self.docs.indexOf(id) : -1;\n          observeCallbacks.changedAt(doc, oldDoc, index);\n        } else {\n          observeCallbacks.changed(doc, oldDoc);\n        }\n      },\n      movedBefore: function (id, before) {\n        var self = this;\n        if (!observeCallbacks.movedTo) return;\n        var from = indices ? self.docs.indexOf(id) : -1;\n        var to = indices ? before ? self.docs.indexOf(before) : self.docs.size() : -1; // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n\n        if (to > from) --to;\n        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))), from, to, before || null);\n      },\n      removed: function (id) {\n        var self = this;\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed)) return; // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from self.docs!\n\n        var doc = transform(self.docs.get(id));\n\n        if (observeCallbacks.removedAt) {\n          var index = indices ? self.docs.indexOf(id) : -1;\n          observeCallbacks.removedAt(doc, index);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      }\n    };\n  } else {\n    observeChangesCallbacks = {\n      added: function (id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          var doc = _.extend(fields, {\n            _id: id\n          });\n\n          observeCallbacks.added(transform(doc));\n        }\n      },\n      changed: function (id, fields) {\n        var self = this;\n\n        if (observeCallbacks.changed) {\n          var oldDoc = self.docs.get(id);\n          var doc = EJSON.clone(oldDoc);\n          DiffSequence.applyChanges(doc, fields);\n          observeCallbacks.changed(transform(doc), transform(EJSON.clone(oldDoc)));\n        }\n      },\n      removed: function (id) {\n        var self = this;\n\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(self.docs.get(id)));\n        }\n      }\n    };\n  }\n\n  var changeObserver = new LocalCollection._CachingChangeObserver({\n    callbacks: observeChangesCallbacks\n  });\n  var handle = cursor.observeChanges(changeObserver.applyChange);\n  suppressed = false;\n  return handle;\n};","map":{"version":3,"sources":["/packages/minimongo/observe.js"],"names":["LocalCollection","_CachingChangeObserver","options","self","orderedFromCallbacks","callbacks","_observeChangesCallbacksAreOrdered","_","has","ordered","Error","docs","OrderedDict","MongoID","idStringify","applyChange","addedBefore","id","fields","before","doc","EJSON","clone","_id","call","added","putBefore","movedBefore","get","moveBefore","_IdMap","set","changed","DiffSequence","applyChanges","removed","remove","_observeFromObserveChanges","cursor","observeCallbacks","transform","getTransform","suppressed","_suppress_initial","observeChangesCallbacks","_observeCallbacksAreOrdered","indices","_no_indices","addedAt","extend","index","indexOf","size","changedAt","oldDoc","movedTo","from","to","removedAt","changeObserver","handle","observeChanges"],"mappings":"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","file":"/packages/minimongo/observe.js.map","sourcesContent":["// XXX maybe move these into another ObserveHelpers package or something\n\n// _CachingChangeObserver is an object which receives observeChanges callbacks\n// and keeps a cache of the current cursor state up to date in self.docs. Users\n// of this class should read the docs field but not modify it. You should pass\n// the \"applyChange\" field as the callbacks to the underlying observeChanges\n// call. Optionally, you can specify your own observeChanges callbacks which are\n// invoked immediately before the docs field is updated; this object is made\n// available as `this` to those callbacks.\nLocalCollection._CachingChangeObserver = function (options) {\n  var self = this;\n  options = options || {};\n\n  var orderedFromCallbacks = options.callbacks &&\n        LocalCollection._observeChangesCallbacksAreOrdered(options.callbacks);\n  if (_.has(options, 'ordered')) {\n    self.ordered = options.ordered;\n    if (options.callbacks && options.ordered !== orderedFromCallbacks)\n      throw Error(\"ordered option doesn't match callbacks\");\n  } else if (options.callbacks) {\n    self.ordered = orderedFromCallbacks;\n  } else {\n    throw Error(\"must provide ordered or callbacks\");\n  }\n  var callbacks = options.callbacks || {};\n\n  if (self.ordered) {\n    self.docs = new OrderedDict(MongoID.idStringify);\n    self.applyChange = {\n      addedBefore: function (id, fields, before) {\n        var doc = EJSON.clone(fields);\n        doc._id = id;\n        callbacks.addedBefore && callbacks.addedBefore.call(\n          self, id, fields, before);\n        // This line triggers if we provide added with movedBefore.\n        callbacks.added && callbacks.added.call(self, id, fields);\n        // XXX could `before` be a falsy ID?  Technically\n        // idStringify seems to allow for them -- though\n        // OrderedDict won't call stringify on a falsy arg.\n        self.docs.putBefore(id, doc, before || null);\n      },\n      movedBefore: function (id, before) {\n        var doc = self.docs.get(id);\n        callbacks.movedBefore && callbacks.movedBefore.call(self, id, before);\n        self.docs.moveBefore(id, before || null);\n      }\n    };\n  } else {\n    self.docs = new LocalCollection._IdMap;\n    self.applyChange = {\n      added: function (id, fields) {\n        var doc = EJSON.clone(fields);\n        callbacks.added && callbacks.added.call(self, id, fields);\n        doc._id = id;\n        self.docs.set(id,  doc);\n      }\n    };\n  }\n\n  // The methods in _IdMap and OrderedDict used by these callbacks are\n  // identical.\n  self.applyChange.changed = function (id, fields) {\n    var doc = self.docs.get(id);\n    if (!doc)\n      throw new Error(\"Unknown id for changed: \" + id);\n    callbacks.changed && callbacks.changed.call(\n      self, id, EJSON.clone(fields));\n    DiffSequence.applyChanges(doc, fields);\n  };\n  self.applyChange.removed = function (id) {\n    callbacks.removed && callbacks.removed.call(self, id);\n    self.docs.remove(id);\n  };\n};\n\nLocalCollection._observeFromObserveChanges = function (cursor, observeCallbacks) {\n  var transform = cursor.getTransform() || function (doc) {return doc;};\n  var suppressed = !!observeCallbacks._suppress_initial;\n\n  var observeChangesCallbacks;\n  if (LocalCollection._observeCallbacksAreOrdered(observeCallbacks)) {\n    // The \"_no_indices\" option sets all index arguments to -1 and skips the\n    // linear scans required to generate them.  This lets observers that don't\n    // need absolute indices benefit from the other features of this API --\n    // relative order, transforms, and applyChanges -- without the speed hit.\n    var indices = !observeCallbacks._no_indices;\n    observeChangesCallbacks = {\n      addedBefore: function (id, fields, before) {\n        var self = this;\n        if (suppressed || !(observeCallbacks.addedAt || observeCallbacks.added))\n          return;\n        var doc = transform(_.extend(fields, {_id: id}));\n        if (observeCallbacks.addedAt) {\n          var index = indices\n                ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;\n          observeCallbacks.addedAt(doc, index, before);\n        } else {\n          observeCallbacks.added(doc);\n        }\n      },\n      changed: function (id, fields) {\n        var self = this;\n        if (!(observeCallbacks.changedAt || observeCallbacks.changed))\n          return;\n        var doc = EJSON.clone(self.docs.get(id));\n        if (!doc)\n          throw new Error(\"Unknown id for changed: \" + id);\n        var oldDoc = transform(EJSON.clone(doc));\n        DiffSequence.applyChanges(doc, fields);\n        doc = transform(doc);\n        if (observeCallbacks.changedAt) {\n          var index = indices ? self.docs.indexOf(id) : -1;\n          observeCallbacks.changedAt(doc, oldDoc, index);\n        } else {\n          observeCallbacks.changed(doc, oldDoc);\n        }\n      },\n      movedBefore: function (id, before) {\n        var self = this;\n        if (!observeCallbacks.movedTo)\n          return;\n        var from = indices ? self.docs.indexOf(id) : -1;\n\n        var to = indices\n              ? (before ? self.docs.indexOf(before) : self.docs.size()) : -1;\n        // When not moving backwards, adjust for the fact that removing the\n        // document slides everything back one slot.\n        if (to > from)\n          --to;\n        observeCallbacks.movedTo(transform(EJSON.clone(self.docs.get(id))),\n                                 from, to, before || null);\n      },\n      removed: function (id) {\n        var self = this;\n        if (!(observeCallbacks.removedAt || observeCallbacks.removed))\n          return;\n        // technically maybe there should be an EJSON.clone here, but it's about\n        // to be removed from self.docs!\n        var doc = transform(self.docs.get(id));\n        if (observeCallbacks.removedAt) {\n          var index = indices ? self.docs.indexOf(id) : -1;\n          observeCallbacks.removedAt(doc, index);\n        } else {\n          observeCallbacks.removed(doc);\n        }\n      }\n    };\n  } else {\n    observeChangesCallbacks = {\n      added: function (id, fields) {\n        if (!suppressed && observeCallbacks.added) {\n          var doc = _.extend(fields, {_id:  id});\n          observeCallbacks.added(transform(doc));\n        }\n      },\n      changed: function (id, fields) {\n        var self = this;\n        if (observeCallbacks.changed) {\n          var oldDoc = self.docs.get(id);\n          var doc = EJSON.clone(oldDoc);\n          DiffSequence.applyChanges(doc, fields);\n          observeCallbacks.changed(transform(doc),\n                                   transform(EJSON.clone(oldDoc)));\n        }\n      },\n      removed: function (id) {\n        var self = this;\n        if (observeCallbacks.removed) {\n          observeCallbacks.removed(transform(self.docs.get(id)));\n        }\n      }\n    };\n  }\n\n  var changeObserver = new LocalCollection._CachingChangeObserver(\n    {callbacks: observeChangesCallbacks});\n  var handle = cursor.observeChanges(changeObserver.applyChange);\n  suppressed = false;\n\n  return handle;\n};\n"]},"hash":"9bfb83b3780b6e0f7183ccdce10b7d849074c105"}
