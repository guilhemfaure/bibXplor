{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[{"source":"./validation.js","imported":["assertHasValidFieldNames"],"specifiers":[{"kind":"named","imported":"assertHasValidFieldNames","local":"assertHasValidFieldNames"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/minimongo.js","filenameRelative":"/packages/minimongo/minimongo.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/minimongo.js.map","sourceFileName":"/packages/minimongo/minimongo.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"minimongo"},"ignored":false,"code":"var assertHasValidFieldNames = void 0;\nmodule.importSync(\"./validation.js\", {\n  assertHasValidFieldNames: function (v) {\n    assertHasValidFieldNames = v;\n  }\n}, 0);\n\n// XXX type checking on selectors (graceful error if malformed)\n// LocalCollection: a set of documents that supports queries and modifiers.\n// Cursor: a specification for a particular subset of documents, w/\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),\n// ObserveHandle: the return value of a live query.\nLocalCollection = function (name) {\n  var self = this;\n  self.name = name; // _id -> document (also containing id)\n\n  self._docs = new LocalCollection._IdMap();\n  self._observeQueue = new Meteor._SynchronousQueue();\n  self.next_qid = 1; // live query id generator\n  // qid -> live query object. keys:\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n  //  results: array (ordered) or object (unordered) of current results\n  //    (aliased with self._docs!)\n  //  resultsSnapshot: snapshot of results. null if not paused.\n  //  cursor: Cursor object for the query.\n  //  selector, sorter, (callbacks): functions\n\n  self.queries = {}; // null if not saving originals; an IdMap from id to original document value if\n  // saving originals. See comments before saveOriginals().\n\n  self._savedOriginals = null; // True when observers are paused and we should not send callbacks.\n\n  self.paused = false;\n};\n\nMinimongo = {}; // Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\n\nMinimongoTest = {};\n\nMinimongoError = function (message) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (typeof message === \"string\" && options.field) {\n    message += \" for field '\" + options.field + \"'\";\n  }\n\n  var e = new Error(message);\n  e.name = \"MinimongoError\";\n  return e;\n}; // options may include sort, skip, limit, reactive\n// sort may be any of these forms:\n//     {a: 1, b: -1}\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n//     [\"a\", [\"b\", \"desc\"]]\n//   (in the first form you're beholden to key enumeration order in\n//   your javascript VM)\n//\n// reactive: if given, and false, don't register with Tracker (default\n// is true)\n//\n// XXX possibly should support retrieving a subset of fields? and\n// have it be a hint (ignored on the client, when not copying the\n// doc?)\n//\n// XXX sort does not yet support subkeys ('a.b') .. fix that!\n// XXX add one more sort form: \"key\"\n// XXX tests\n\n\nLocalCollection.prototype.find = function (selector, options) {\n  // default syntax for everything is to omit the selector argument.\n  // but if selector is explicitly passed in as false or undefined, we\n  // want a selector that matches nothing.\n  if (arguments.length === 0) selector = {};\n  return new LocalCollection.Cursor(this, selector, options);\n}; // don't call this ctor directly.  use LocalCollection.find().\n\n\nLocalCollection.Cursor = function (collection, selector, options) {\n  var self = this;\n  if (!options) options = {};\n  self.collection = collection;\n  self.sorter = null;\n  self.matcher = new Minimongo.Matcher(selector);\n\n  if (LocalCollection._selectorIsId(selector)) {\n    // stash for fast path\n    self._selectorId = selector;\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    // also do the fast path for { _id: idString }\n    self._selectorId = selector._id;\n  } else {\n    self._selectorId = undefined;\n\n    if (self.matcher.hasGeoQuery() || options.sort) {\n      self.sorter = new Minimongo.Sorter(options.sort || [], {\n        matcher: self.matcher\n      });\n    }\n  }\n\n  self.skip = options.skip;\n  self.limit = options.limit;\n  self.fields = options.fields;\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});\n  self._transform = LocalCollection.wrapTransform(options.transform); // by default, queries register w/ Tracker when it is available.\n\n  if (typeof Tracker !== \"undefined\") self.reactive = options.reactive === undefined ? true : options.reactive;\n}; // Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\n\n\nLocalCollection.Cursor.prototype.rewind = function () {};\n\nLocalCollection.prototype.findOne = function (selector, options) {\n  if (arguments.length === 0) selector = {}; // NOTE: by setting limit 1 here, we end up using very inefficient\n  // code that recomputes the whole query on each update. The upside is\n  // that when you reactively depend on a findOne you only get\n  // invalidated when the found object changes, not any object in the\n  // collection. Most findOne will be by id, which has a fast path, so\n  // this might not be a big deal. In most cases, invalidation causes\n  // the called to re-query anyway, so this should be a net performance\n  // improvement.\n\n  options = options || {};\n  options.limit = 1;\n  return this.find(selector, options).fetch()[0];\n}; /**\n    * @callback IterationCallback\n    * @param {Object} doc\n    * @param {Number} index\n    */ /**\n        * @summary Call `callback` once for each matching document, sequentially and synchronously.\n        * @locus Anywhere\n        * @method  forEach\n        * @instance\n        * @memberOf Mongo.Cursor\n        * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n        * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n        */\n\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {\n  var self = this;\n\n  var objects = self._getRawObjects({\n    ordered: true\n  });\n\n  if (self.reactive) {\n    self._depend({\n      addedBefore: true,\n      removed: true,\n      changed: true,\n      movedBefore: true\n    });\n  }\n\n  _.each(objects, function (elt, i) {\n    // This doubles as a clone operation.\n    elt = self._projectionFn(elt);\n    if (self._transform) elt = self._transform(elt);\n    callback.call(thisArg, elt, i, self);\n  });\n};\n\nLocalCollection.Cursor.prototype.getTransform = function () {\n  return this._transform;\n}; /**\n    * @summary Map callback over all matching documents.  Returns an Array.\n    * @locus Anywhere\n    * @method map\n    * @instance\n    * @memberOf Mongo.Cursor\n    * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n    * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n    */\n\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc, index) {\n    res.push(callback.call(thisArg, doc, index, self));\n  });\n  return res;\n}; /**\n    * @summary Return all matching documents as an Array.\n    * @memberOf Mongo.Cursor\n    * @method  fetch\n    * @instance\n    * @locus Anywhere\n    * @returns {Object[]}\n    */\n\nLocalCollection.Cursor.prototype.fetch = function () {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc) {\n    res.push(doc);\n  });\n  return res;\n}; /**\n    * @summary Returns the number of documents that match a query.\n    * @memberOf Mongo.Cursor\n    * @method  count\n    * @instance\n    * @locus Anywhere\n    * @returns {Number}\n    */\n\nLocalCollection.Cursor.prototype.count = function () {\n  var self = this;\n  if (self.reactive) self._depend({\n    added: true,\n    removed: true\n  }, true /* allow the observe to be unordered */);\n  return self._getRawObjects({\n    ordered: true\n  }).length;\n};\n\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  if (!self.collection.name) throw new Error(\"Can't publish a cursor from a collection without a name.\");\n  var collection = self.collection.name; // XXX minimongo should not depend on mongo-livedata!\n\n  if (!Package.mongo) {\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n  }\n\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);\n};\n\nLocalCollection.Cursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self.collection.name;\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore) throw new Error(\"Please specify only one of added() and addedBefore()\");\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.addedAt && callbacks.added) throw new Error(\"Please specify only one of added() and addedAt()\");\n  if (callbacks.changedAt && callbacks.changed) throw new Error(\"Please specify only one of changed() and changedAt()\");\n  if (callbacks.removed && callbacks.removedAt) throw new Error(\"Please specify only one of removed() and removedAt()\");\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt || callbacks.removedAt);\n}; // the handle that comes back from observe.\n\n\nLocalCollection.ObserveHandle = function () {}; // options to contain:\n//  * callbacks for observe():\n//    - addedAt (document, atIndex)\n//    - added (document)\n//    - changedAt (newDocument, oldDocument, atIndex)\n//    - changed (newDocument, oldDocument)\n//    - removedAt (document, atIndex)\n//    - removed (document)\n//    - movedTo (document, oldIndex, newIndex)\n//\n// attributes available on returned query handle:\n//  * stop(): end updates\n//  * collection: the collection this query is querying\n//\n// iff x is a returned query handle, (x instanceof\n// LocalCollection.ObserveHandle) is true\n//\n// initial results delivered through added callback\n// XXX maybe callbacks should take a list of objects, to expose transactions?\n// XXX maybe support field limiting (to limit what you're notified on)\n\n\n_.extend(LocalCollection.Cursor.prototype, {\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */observe: function (options) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, options);\n  },\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */observeChanges: function (options) {\n    var self = this;\n\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options); // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n\n\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit)) throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false)) throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n    var query = {\n      dirty: false,\n      matcher: self.matcher,\n      // not fast pathed\n      sorter: ordered && self.sorter,\n      distances: self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap(),\n      resultsSnapshot: null,\n      ordered: ordered,\n      cursor: self,\n      projectionFn: self._projectionFn\n    };\n    var qid; // Non-reactive queries call added[Before] and then never call anything\n    // else.\n\n    if (self.reactive) {\n      qid = self.collection.next_qid++;\n      self.collection.queries[qid] = query;\n    }\n\n    query.results = self._getRawObjects({\n      ordered: ordered,\n      distances: query.distances\n    });\n    if (self.collection.paused) query.resultsSnapshot = ordered ? [] : new LocalCollection._IdMap(); // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n\n    var wrapCallback = function (f) {\n      if (!f) return function () {};\n      return function () /*args*/{\n        var context = this;\n        var args = arguments;\n        if (self.collection.paused) return;\n\n        self.collection._observeQueue.queueTask(function () {\n          f.apply(context, args);\n        });\n      };\n    };\n\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !self.collection.paused) {\n      // XXX unify ordered and unordered interface\n      var each = ordered ? _.bind(_.each, null, query.results) : _.bind(query.results.forEach, query.results);\n      each(function (doc) {\n        var fields = EJSON.clone(doc);\n        delete fields._id;\n        if (ordered) query.addedBefore(doc._id, self._projectionFn(fields), null);\n        query.added(doc._id, self._projectionFn(fields));\n      });\n    }\n\n    var handle = new LocalCollection.ObserveHandle();\n\n    _.extend(handle, {\n      collection: self.collection,\n      stop: function () {\n        if (self.reactive) delete self.collection.queries[qid];\n      }\n    });\n\n    if (self.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(function () {\n        handle.stop();\n      });\n    } // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n\n\n    self.collection._observeQueue.drain();\n\n    return handle;\n  }\n}); // Returns a collection of matching objects, but doesn't deep copy them.\n//\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit\n// properties of the query.  if sorter is falsey, no sort -- you get the natural\n// order.\n//\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip\n// and limit should not be set).\n//\n// If ordered is set and this cursor is a $near geoquery, then this function\n// will use an _IdMap to track each distance from the $near argument point in\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'\n// argument, this function will clear it and use it for this purpose (otherwise\n// it will just create its own _IdMap). The observeChanges implementation uses\n// this to remember the distances after this function returns.\n\n\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {\n  var self = this;\n  options = options || {}; // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n  // compatible\n\n  var results = options.ordered ? [] : new LocalCollection._IdMap(); // fast path for single ID value\n\n  if (self._selectorId !== undefined) {\n    // If you have non-zero skip and ask for a single id, you get\n    // nothing. This is so it matches the behavior of the '{_id: foo}'\n    // path.\n    if (self.skip) return results;\n\n    var selectedDoc = self.collection._docs.get(self._selectorId);\n\n    if (selectedDoc) {\n      if (options.ordered) results.push(selectedDoc);else results.set(self._selectorId, selectedDoc);\n    }\n\n    return results;\n  } // slow path for arbitrary selector, sort, skip, limit\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,\n  // live results set) object.  in other cases, distances is only used inside\n  // this function.\n\n\n  var distances;\n\n  if (self.matcher.hasGeoQuery() && options.ordered) {\n    if (options.distances) {\n      distances = options.distances;\n      distances.clear();\n    } else {\n      distances = new LocalCollection._IdMap();\n    }\n  }\n\n  self.collection._docs.forEach(function (doc, id) {\n    var matchResult = self.matcher.documentMatches(doc);\n\n    if (matchResult.result) {\n      if (options.ordered) {\n        results.push(doc);\n        if (distances && matchResult.distance !== undefined) distances.set(id, matchResult.distance);\n      } else {\n        results.set(id, doc);\n      }\n    } // Fast path for limited unsorted queries.\n    // XXX 'length' check here seems wrong for ordered\n\n\n    if (self.limit && !self.skip && !self.sorter && results.length === self.limit) return false; // break\n\n    return true; // continue\n  });\n\n  if (!options.ordered) return results;\n\n  if (self.sorter) {\n    var comparator = self.sorter.getComparator({\n      distances: distances\n    });\n    results.sort(comparator);\n  }\n\n  var idx_start = self.skip || 0;\n  var idx_end = self.limit ? self.limit + idx_start : results.length;\n  return results.slice(idx_start, idx_end);\n}; // XXX Maybe we need a version of observe that just calls a callback if\n// anything changed.\n\n\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {\n  var self = this;\n\n  if (Tracker.active) {\n    var v = new Tracker.Dependency();\n    v.depend();\n\n    var notifyChange = _.bind(v.changed, v);\n\n    var options = {\n      _suppress_initial: true,\n      _allow_unordered: _allow_unordered\n    };\n\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'], function (fnName) {\n      if (changers[fnName]) options[fnName] = notifyChange;\n    }); // observeChanges will stop() when this computation is invalidated\n\n\n    self.observeChanges(options);\n  }\n}; // XXX possibly enforce that 'undefined' does not appear (we assume\n// this in our handling of null and $exists)\n\n\nLocalCollection.prototype.insert = function (doc, callback) {\n  var self = this;\n  doc = EJSON.clone(doc);\n  assertHasValidFieldNames(doc);\n\n  if (!_.has(doc, '_id')) {\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID() : Random.id();\n  }\n\n  var id = doc._id;\n  if (self._docs.has(id)) throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n\n  self._saveOriginal(id, undefined);\n\n  self._docs.set(id, doc);\n\n  var queriesToRecompute = []; // trigger live queries that match\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n    var matchResult = query.matcher.documentMatches(doc);\n\n    if (matchResult.result) {\n      if (query.distances && matchResult.distance !== undefined) query.distances.set(id, matchResult.distance);\n      if (query.cursor.skip || query.cursor.limit) queriesToRecompute.push(qid);else LocalCollection._insertInResults(query, doc);\n    }\n  }\n\n  _.each(queriesToRecompute, function (qid) {\n    if (self.queries[qid]) self._recomputeResults(self.queries[qid]);\n  });\n\n  self._observeQueue.drain(); // Defer because the caller likely doesn't expect the callback to be run\n  // immediately.\n\n\n  if (callback) Meteor.defer(function () {\n    callback(null, id);\n  });\n  return id;\n}; // Iterates over a subset of documents that could match selector; calls\n// f(doc, id) on each of them.  Specifically, if selector specifies\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the\n// same object that is in _docs.\n\n\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {\n  var self = this;\n\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n\n  if (specificIds) {\n    for (var i = 0; i < specificIds.length; ++i) {\n      var id = specificIds[i];\n\n      var doc = self._docs.get(id);\n\n      if (doc) {\n        var breakIfFalse = f(doc, id);\n        if (breakIfFalse === false) break;\n      }\n    }\n  } else {\n    self._docs.forEach(f);\n  }\n};\n\nLocalCollection.prototype.remove = function (selector, callback) {\n  var self = this; // Easy special case: if we're not calling observeChanges callbacks and we're\n  // not saving originals and we got asked to remove everything, then just empty\n  // everything directly.\n\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {\n    var result = self._docs.size();\n\n    self._docs.clear();\n\n    _.each(self.queries, function (query) {\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n\n    if (callback) {\n      Meteor.defer(function () {\n        callback(null, result);\n      });\n    }\n\n    return result;\n  }\n\n  var matcher = new Minimongo.Matcher(selector);\n  var remove = [];\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    if (matcher.documentMatches(doc).result) remove.push(id);\n  });\n\n  var queriesToRecompute = [];\n  var queryRemove = [];\n\n  for (var i = 0; i < remove.length; i++) {\n    var removeId = remove[i];\n\n    var removeDoc = self._docs.get(removeId);\n\n    _.each(self.queries, function (query, qid) {\n      if (query.dirty) return;\n\n      if (query.matcher.documentMatches(removeDoc).result) {\n        if (query.cursor.skip || query.cursor.limit) queriesToRecompute.push(qid);else queryRemove.push({\n          qid: qid,\n          doc: removeDoc\n        });\n      }\n    });\n\n    self._saveOriginal(removeId, removeDoc);\n\n    self._docs.remove(removeId);\n  } // run live query callbacks _after_ we've removed the documents.\n\n\n  _.each(queryRemove, function (remove) {\n    var query = self.queries[remove.qid];\n\n    if (query) {\n      query.distances && query.distances.remove(remove.doc._id);\n\n      LocalCollection._removeFromResults(query, remove.doc);\n    }\n  });\n\n  _.each(queriesToRecompute, function (qid) {\n    var query = self.queries[qid];\n    if (query) self._recomputeResults(query);\n  });\n\n  self._observeQueue.drain();\n\n  result = remove.length;\n  if (callback) Meteor.defer(function () {\n    callback(null, result);\n  });\n  return result;\n}; // XXX atomicity: if multi is true, and one modification fails, do\n// we rollback the whole operation, or what?\n\n\nLocalCollection.prototype.update = function (selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (!options) options = {};\n  var matcher = new Minimongo.Matcher(selector); // Save the original results of any query that we might need to\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n  // it. (We don't need to save the original results of paused queries because\n  // they already have a resultsSnapshot and we won't be diffing in\n  // _recomputeResults.)\n\n  var qidToOriginalResults = {}; // We should only clone each document once, even if it appears in multiple queries\n\n  var docMap = new LocalCollection._IdMap();\n\n  var idsMatchedBySelector = LocalCollection._idsMatchedBySelector(selector);\n\n  _.each(self.queries, function (query, qid) {\n    if ((query.cursor.skip || query.cursor.limit) && !self.paused) {\n      // Catch the case of a reactive `count()` on a cursor with skip\n      // or limit, which registers an unordered observe. This is a\n      // pretty rare case, so we just clone the entire result set with\n      // no optimizations for documents that appear in these result\n      // sets and other queries.\n      if (query.results instanceof LocalCollection._IdMap) {\n        qidToOriginalResults[qid] = query.results.clone();\n        return;\n      }\n\n      if (!(query.results instanceof Array)) {\n        throw new Error(\"Assertion failed: query.results not an array\");\n      } // Clones a document to be stored in `qidToOriginalResults`\n      // because it may be modified before the new and old result sets\n      // are diffed. But if we know exactly which document IDs we're\n      // going to modify, then we only need to clone those.\n\n\n      var memoizedCloneIfNeeded = function (doc) {\n        if (docMap.has(doc._id)) {\n          return docMap.get(doc._id);\n        } else {\n          var docToMemoize;\n\n          if (idsMatchedBySelector && !_.any(idsMatchedBySelector, function (id) {\n            return EJSON.equals(id, doc._id);\n          })) {\n            docToMemoize = doc;\n          } else {\n            docToMemoize = EJSON.clone(doc);\n          }\n\n          docMap.set(doc._id, docToMemoize);\n          return docToMemoize;\n        }\n      };\n\n      qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n    }\n  });\n\n  var recomputeQids = {};\n  var updateCount = 0;\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    var queryResult = matcher.documentMatches(doc);\n\n    if (queryResult.result) {\n      // XXX Should we save the original even if mod ends up being a no-op?\n      self._saveOriginal(id, doc);\n\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n\n      ++updateCount;\n      if (!options.multi) return false; // break\n    }\n\n    return true;\n  });\n\n  _.each(recomputeQids, function (dummy, qid) {\n    var query = self.queries[qid];\n    if (query) self._recomputeResults(query, qidToOriginalResults[qid]);\n  });\n\n  self._observeQueue.drain(); // If we are doing an upsert, and we didn't modify any documents yet, then\n  // it's time to do an insert. Figure out what document we are inserting, and\n  // generate an id for it.\n\n\n  var insertedId;\n\n  if (updateCount === 0 && options.upsert) {\n    var newDoc = LocalCollection._removeDollarOperators(selector);\n\n    LocalCollection._modify(newDoc, mod, {\n      isInsert: true\n    });\n\n    if (!newDoc._id && options.insertedId) newDoc._id = options.insertedId;\n    insertedId = self.insert(newDoc);\n    updateCount = 1;\n  } // Return the number of affected documents, or in the upsert case, an object\n  // containing the number of affected docs and the id of the doc that was\n  // inserted, if any.\n\n\n  var result;\n\n  if (options._returnObject) {\n    result = {\n      numberAffected: updateCount\n    };\n    if (insertedId !== undefined) result.insertedId = insertedId;\n  } else {\n    result = updateCount;\n  }\n\n  if (callback) Meteor.defer(function () {\n    callback(null, result);\n  });\n  return result;\n}; // A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:\n// true }).\n\n\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nLocalCollection.prototype._modifyAndNotify = function (doc, mod, recomputeQids, arrayIndices) {\n  var self = this;\n  var matched_before = {};\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n\n    if (query.ordered) {\n      matched_before[qid] = query.matcher.documentMatches(doc).result;\n    } else {\n      // Because we don't support skip or limit (yet) in unordered queries, we\n      // can just do a direct lookup.\n      matched_before[qid] = query.results.has(doc._id);\n    }\n  }\n\n  var old_doc = EJSON.clone(doc);\n\n  LocalCollection._modify(doc, mod, {\n    arrayIndices: arrayIndices\n  });\n\n  for (qid in meteorBabelHelpers.sanitizeForInObject(self.queries)) {\n    query = self.queries[qid];\n    if (query.dirty) continue;\n    var before = matched_before[qid];\n    var afterMatch = query.matcher.documentMatches(doc);\n    var after = afterMatch.result;\n    if (after && query.distances && afterMatch.distance !== undefined) query.distances.set(doc._id, afterMatch.distance);\n\n    if (query.cursor.skip || query.cursor.limit) {\n      // We need to recompute any query where the doc may have been in the\n      // cursor's window either before or after the update. (Note that if skip\n      // or limit is set, \"before\" and \"after\" being true do not necessarily\n      // mean that the document is in the cursor's output after skip/limit is\n      // applied... but if they are false, then the document definitely is NOT\n      // in the output. So it's safe to skip recompute if neither before or\n      // after are true.)\n      if (before || after) recomputeQids[qid] = true;\n    } else if (before && !after) {\n      LocalCollection._removeFromResults(query, doc);\n    } else if (!before && after) {\n      LocalCollection._insertInResults(query, doc);\n    } else if (before && after) {\n      LocalCollection._updateInResults(query, doc, old_doc);\n    }\n  }\n}; // XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\n\nLocalCollection._insertInResults = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(query.sorter.getComparator({\n        distances: query.distances\n      }), query.results, doc);\n\n      var next = query.results[i + 1];\n      if (next) next = next._id;else next = null;\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._removeFromResults = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id; // in case callback mutates doc\n\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._updateInResults = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id)) throw new Error(\"Can't change a doc's _id while updating\");\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(projectionFn(doc), projectionFn(old_doc));\n\n  if (!query.ordered) {\n    if (!_.isEmpty(changedFields)) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n\n    return;\n  }\n\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (!_.isEmpty(changedFields)) query.changed(doc._id, changedFields);\n  if (!query.sorter) return; // just take it out and put it back in again, and see if the index\n  // changes\n\n  query.results.splice(orig_idx, 1);\n\n  var new_idx = LocalCollection._insertInSortedList(query.sorter.getComparator({\n    distances: query.distances\n  }), query.results, doc);\n\n  if (orig_idx !== new_idx) {\n    var next = query.results[new_idx + 1];\n    if (next) next = next._id;else next = null;\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n}; // Recomputes the results of a query and runs observe callbacks for the\n// difference between the previous results and the current results (unless\n// paused). Used for skip/limit queries.\n//\n// When this is used by insert or remove, it can just use query.results for the\n// old results (and there's no need to pass in oldResults), because these\n// operations don't mutate the documents in the collection. Update needs to pass\n// in an oldResults which was deep-copied before the modifier was applied.\n//\n// oldResults is guaranteed to be ignored if the query is not paused.\n\n\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {\n  var self = this;\n\n  if (self.paused) {\n    // There's no reason to recompute the results now as we're still paused.\n    // By flagging the query as \"dirty\", the recompute will be performed\n    // when resumeObservers is called.\n    query.dirty = true;\n    return;\n  }\n\n  if (!self.paused && !oldResults) oldResults = query.results;\n  if (query.distances) query.distances.clear();\n  query.results = query.cursor._getRawObjects({\n    ordered: query.ordered,\n    distances: query.distances\n  });\n\n  if (!self.paused) {\n    LocalCollection._diffQueryChanges(query.ordered, oldResults, query.results, query, {\n      projectionFn: query.projectionFn\n    });\n  }\n};\n\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered) throw new Error(\"Can't call _findInOrderedResults on unordered query\");\n\n  for (var i = 0; i < query.results.length; i++) {\n    if (query.results[i] === doc) return i;\n  }\n\n  throw Error(\"object missing from query\");\n}; // This binary search puts a value between any equal values, and the first\n// lesser value.\n\n\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0,\n      rangeLength = array.length;\n\n  while (rangeLength > 0) {\n    var halfRange = Math.floor(rangeLength / 2);\n\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      rangeLength -= halfRange + 1;\n    } else {\n      rangeLength = halfRange;\n    }\n  }\n\n  return first;\n};\n\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  var idx = LocalCollection._binarySearch(cmp, array, value);\n\n  array.splice(idx, 0, value);\n  return idx;\n}; // To track what documents are affected by a piece of code, call saveOriginals()\n// before it and retrieveOriginals() after it. retrieveOriginals returns an\n// object whose keys are the ids of the documents that were affected since the\n// call to saveOriginals(), and the values are equal to the document's contents\n// at the time of saveOriginals. (In the case of an inserted document, undefined\n// is the value.) You must alternate between calls to saveOriginals() and\n// retrieveOriginals().\n\n\nLocalCollection.prototype.saveOriginals = function () {\n  var self = this;\n  if (self._savedOriginals) throw new Error(\"Called saveOriginals twice without retrieveOriginals\");\n  self._savedOriginals = new LocalCollection._IdMap();\n};\n\nLocalCollection.prototype.retrieveOriginals = function () {\n  var self = this;\n  if (!self._savedOriginals) throw new Error(\"Called retrieveOriginals without saveOriginals\");\n  var originals = self._savedOriginals;\n  self._savedOriginals = null;\n  return originals;\n};\n\nLocalCollection.prototype._saveOriginal = function (id, doc) {\n  var self = this; // Are we even trying to save originals?\n\n  if (!self._savedOriginals) return; // Have we previously mutated the original (and so 'doc' is not actually\n  // original)?  (Note the 'has' check rather than truth: we store undefined\n  // here for inserted docs!)\n\n  if (self._savedOriginals.has(id)) return;\n\n  self._savedOriginals.set(id, EJSON.clone(doc));\n}; // Pause the observers. No callbacks from observers will fire until\n// 'resumeObservers' is called.\n\n\nLocalCollection.prototype.pauseObservers = function () {\n  // No-op if already paused.\n  if (this.paused) return; // Set the 'paused' flag such that new observer messages don't fire.\n\n  this.paused = true; // Take a snapshot of the query results for each query.\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(this.queries)) {\n    var query = this.queries[qid];\n    query.resultsSnapshot = EJSON.clone(query.results);\n  }\n}; // Resume the observers. Observers immediately receive change\n// notifications to bring them to the current state of the\n// database. Note that this is not just replaying all the changes that\n// happened during the pause, it is a smarter 'coalesced' diff.\n\n\nLocalCollection.prototype.resumeObservers = function () {\n  var self = this; // No-op if not paused.\n\n  if (!this.paused) return; // Unset the 'paused' flag. Make sure to do this first, otherwise\n  // observer methods won't actually fire when we trigger them.\n\n  this.paused = false;\n\n  for (var qid in meteorBabelHelpers.sanitizeForInObject(this.queries)) {\n    var query = self.queries[qid];\n\n    if (query.dirty) {\n      query.dirty = false; // re-compute results will perform `LocalCollection._diffQueryChanges` automatically.\n\n      self._recomputeResults(query, query.resultsSnapshot);\n    } else {\n      // Diff the current results against the snapshot and send to observers.\n      // pass the query object for its observer callbacks.\n      LocalCollection._diffQueryChanges(query.ordered, query.resultsSnapshot, query.results, query, {\n        projectionFn: query.projectionFn\n      });\n    }\n\n    query.resultsSnapshot = null;\n  }\n\n  self._observeQueue.drain();\n};","map":{"version":3,"sources":["/packages/minimongo/minimongo.js"],"names":["assertHasValidFieldNames","module","importSync","v","LocalCollection","name","self","_docs","_IdMap","_observeQueue","Meteor","_SynchronousQueue","next_qid","queries","_savedOriginals","paused","Minimongo","MinimongoTest","MinimongoError","message","options","field","e","Error","prototype","find","selector","arguments","length","Cursor","collection","sorter","matcher","Matcher","_selectorIsId","_selectorId","_selectorIsIdPerhapsAsObject","_id","undefined","hasGeoQuery","sort","Sorter","skip","limit","fields","_projectionFn","_compileProjection","_transform","wrapTransform","transform","Tracker","reactive","rewind","findOne","fetch","forEach","callback","thisArg","objects","_getRawObjects","ordered","_depend","addedBefore","removed","changed","movedBefore","_","each","elt","i","call","getTransform","map","res","doc","index","push","count","added","_publishCursor","sub","Package","mongo","Mongo","Collection","_getCollectionName","_observeChangesCallbacksAreOrdered","callbacks","_observeCallbacksAreOrdered","addedAt","changedAt","removedAt","movedTo","ObserveHandle","extend","observe","_observeFromObserveChanges","observeChanges","_allow_unordered","query","dirty","distances","resultsSnapshot","cursor","projectionFn","qid","results","wrapCallback","f","context","args","queueTask","apply","_suppress_initial","bind","EJSON","clone","handle","stop","active","onInvalidate","drain","selectedDoc","get","set","clear","id","matchResult","documentMatches","result","distance","comparator","getComparator","idx_start","idx_end","slice","changers","Dependency","depend","notifyChange","fnName","insert","has","_useOID","MongoID","ObjectID","Random","_saveOriginal","queriesToRecompute","_insertInResults","_recomputeResults","defer","_eachPossiblyMatchingDoc","specificIds","_idsMatchedBySelector","breakIfFalse","remove","equals","size","queryRemove","removeId","removeDoc","_removeFromResults","update","mod","Function","qidToOriginalResults","docMap","idsMatchedBySelector","Array","memoizedCloneIfNeeded","docToMemoize","any","recomputeQids","updateCount","queryResult","_modifyAndNotify","arrayIndices","multi","dummy","insertedId","upsert","newDoc","_removeDollarOperators","_modify","isInsert","_returnObject","numberAffected","matched_before","old_doc","before","afterMatch","after","_updateInResults","_insertInSortedList","next","_findInOrderedResults","splice","changedFields","DiffSequence","makeChangedFields","isEmpty","orig_idx","new_idx","oldResults","_diffQueryChanges","_binarySearch","cmp","array","value","first","rangeLength","halfRange","Math","floor","idx","saveOriginals","retrieveOriginals","originals","pauseObservers","resumeObservers"],"mappings":"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","file":"/packages/minimongo/minimongo.js.map","sourcesContent":["import { assertHasValidFieldNames } from './validation.js';\n\n// XXX type checking on selectors (graceful error if malformed)\n\n// LocalCollection: a set of documents that supports queries and modifiers.\n\n// Cursor: a specification for a particular subset of documents, w/\n// a defined order, limit, and offset.  creating a Cursor with LocalCollection.find(),\n\n// ObserveHandle: the return value of a live query.\n\nLocalCollection = function (name) {\n  var self = this;\n  self.name = name;\n  // _id -> document (also containing id)\n  self._docs = new LocalCollection._IdMap;\n\n  self._observeQueue = new Meteor._SynchronousQueue();\n\n  self.next_qid = 1; // live query id generator\n\n  // qid -> live query object. keys:\n  //  ordered: bool. ordered queries have addedBefore/movedBefore callbacks.\n  //  results: array (ordered) or object (unordered) of current results\n  //    (aliased with self._docs!)\n  //  resultsSnapshot: snapshot of results. null if not paused.\n  //  cursor: Cursor object for the query.\n  //  selector, sorter, (callbacks): functions\n  self.queries = {};\n\n  // null if not saving originals; an IdMap from id to original document value if\n  // saving originals. See comments before saveOriginals().\n  self._savedOriginals = null;\n\n  // True when observers are paused and we should not send callbacks.\n  self.paused = false;\n};\n\nMinimongo = {};\n\n// Object exported only for unit testing.\n// Use it to export private functions to test in Tinytest.\nMinimongoTest = {};\n\nMinimongoError = function (message, options={}) {\n  if (typeof message === \"string\" && options.field) {\n    message += ` for field '${options.field}'`;\n  }\n\n  var e = new Error(message);\n  e.name = \"MinimongoError\";\n  return e;\n};\n\n\n// options may include sort, skip, limit, reactive\n// sort may be any of these forms:\n//     {a: 1, b: -1}\n//     [[\"a\", \"asc\"], [\"b\", \"desc\"]]\n//     [\"a\", [\"b\", \"desc\"]]\n//   (in the first form you're beholden to key enumeration order in\n//   your javascript VM)\n//\n// reactive: if given, and false, don't register with Tracker (default\n// is true)\n//\n// XXX possibly should support retrieving a subset of fields? and\n// have it be a hint (ignored on the client, when not copying the\n// doc?)\n//\n// XXX sort does not yet support subkeys ('a.b') .. fix that!\n// XXX add one more sort form: \"key\"\n// XXX tests\nLocalCollection.prototype.find = function (selector, options) {\n  // default syntax for everything is to omit the selector argument.\n  // but if selector is explicitly passed in as false or undefined, we\n  // want a selector that matches nothing.\n  if (arguments.length === 0)\n    selector = {};\n\n  return new LocalCollection.Cursor(this, selector, options);\n};\n\n// don't call this ctor directly.  use LocalCollection.find().\n\nLocalCollection.Cursor = function (collection, selector, options) {\n  var self = this;\n  if (!options) options = {};\n\n  self.collection = collection;\n  self.sorter = null;\n  self.matcher = new Minimongo.Matcher(selector);\n\n  if (LocalCollection._selectorIsId(selector)) {\n    // stash for fast path\n    self._selectorId = selector;\n  } else if (LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    // also do the fast path for { _id: idString }\n    self._selectorId = selector._id;\n  } else {\n    self._selectorId = undefined;\n    if (self.matcher.hasGeoQuery() || options.sort) {\n      self.sorter = new Minimongo.Sorter(options.sort || [],\n                                         { matcher: self.matcher });\n    }\n  }\n\n  self.skip = options.skip;\n  self.limit = options.limit;\n  self.fields = options.fields;\n\n  self._projectionFn = LocalCollection._compileProjection(self.fields || {});\n\n  self._transform = LocalCollection.wrapTransform(options.transform);\n\n  // by default, queries register w/ Tracker when it is available.\n  if (typeof Tracker !== \"undefined\")\n    self.reactive = (options.reactive === undefined) ? true : options.reactive;\n};\n\n// Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\nLocalCollection.Cursor.prototype.rewind = function () {\n};\n\nLocalCollection.prototype.findOne = function (selector, options) {\n  if (arguments.length === 0)\n    selector = {};\n\n  // NOTE: by setting limit 1 here, we end up using very inefficient\n  // code that recomputes the whole query on each update. The upside is\n  // that when you reactively depend on a findOne you only get\n  // invalidated when the found object changes, not any object in the\n  // collection. Most findOne will be by id, which has a fast path, so\n  // this might not be a big deal. In most cases, invalidation causes\n  // the called to re-query anyway, so this should be a net performance\n  // improvement.\n  options = options || {};\n  options.limit = 1;\n\n  return this.find(selector, options).fetch()[0];\n};\n\n/**\n * @callback IterationCallback\n * @param {Object} doc\n * @param {Number} index\n */\n/**\n * @summary Call `callback` once for each matching document, sequentially and synchronously.\n * @locus Anywhere\n * @method  forEach\n * @instance\n * @memberOf Mongo.Cursor\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n */\nLocalCollection.Cursor.prototype.forEach = function (callback, thisArg) {\n  var self = this;\n\n  var objects = self._getRawObjects({ordered: true});\n\n  if (self.reactive) {\n    self._depend({\n      addedBefore: true,\n      removed: true,\n      changed: true,\n      movedBefore: true});\n  }\n\n  _.each(objects, function (elt, i) {\n    // This doubles as a clone operation.\n    elt = self._projectionFn(elt);\n\n    if (self._transform)\n      elt = self._transform(elt);\n    callback.call(thisArg, elt, i, self);\n  });\n};\n\nLocalCollection.Cursor.prototype.getTransform = function () {\n  return this._transform;\n};\n\n/**\n * @summary Map callback over all matching documents.  Returns an Array.\n * @locus Anywhere\n * @method map\n * @instance\n * @memberOf Mongo.Cursor\n * @param {IterationCallback} callback Function to call. It will be called with three arguments: the document, a 0-based index, and <em>cursor</em> itself.\n * @param {Any} [thisArg] An object which will be the value of `this` inside `callback`.\n */\nLocalCollection.Cursor.prototype.map = function (callback, thisArg) {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc, index) {\n    res.push(callback.call(thisArg, doc, index, self));\n  });\n  return res;\n};\n\n/**\n * @summary Return all matching documents as an Array.\n * @memberOf Mongo.Cursor\n * @method  fetch\n * @instance\n * @locus Anywhere\n * @returns {Object[]}\n */\nLocalCollection.Cursor.prototype.fetch = function () {\n  var self = this;\n  var res = [];\n  self.forEach(function (doc) {\n    res.push(doc);\n  });\n  return res;\n};\n\n/**\n * @summary Returns the number of documents that match a query.\n * @memberOf Mongo.Cursor\n * @method  count\n * @instance\n * @locus Anywhere\n * @returns {Number}\n */\nLocalCollection.Cursor.prototype.count = function () {\n  var self = this;\n\n  if (self.reactive)\n    self._depend({added: true, removed: true},\n                 true /* allow the observe to be unordered */);\n\n  return self._getRawObjects({ordered: true}).length;\n};\n\nLocalCollection.Cursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  if (! self.collection.name)\n    throw new Error(\"Can't publish a cursor from a collection without a name.\");\n  var collection = self.collection.name;\n\n  // XXX minimongo should not depend on mongo-livedata!\n  if (! Package.mongo) {\n    throw new Error(\"Can't publish from Minimongo without the `mongo` package.\");\n  }\n\n  return Package.mongo.Mongo.Collection._publishCursor(self, sub, collection);\n};\n\nLocalCollection.Cursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self.collection.name;\n};\n\nLocalCollection._observeChangesCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.added && callbacks.addedBefore)\n    throw new Error(\"Please specify only one of added() and addedBefore()\");\n  return !!(callbacks.addedBefore || callbacks.movedBefore);\n};\n\nLocalCollection._observeCallbacksAreOrdered = function (callbacks) {\n  if (callbacks.addedAt && callbacks.added)\n    throw new Error(\"Please specify only one of added() and addedAt()\");\n  if (callbacks.changedAt && callbacks.changed)\n    throw new Error(\"Please specify only one of changed() and changedAt()\");\n  if (callbacks.removed && callbacks.removedAt)\n    throw new Error(\"Please specify only one of removed() and removedAt()\");\n\n  return !!(callbacks.addedAt || callbacks.movedTo || callbacks.changedAt\n            || callbacks.removedAt);\n};\n\n// the handle that comes back from observe.\nLocalCollection.ObserveHandle = function () {};\n\n// options to contain:\n//  * callbacks for observe():\n//    - addedAt (document, atIndex)\n//    - added (document)\n//    - changedAt (newDocument, oldDocument, atIndex)\n//    - changed (newDocument, oldDocument)\n//    - removedAt (document, atIndex)\n//    - removed (document)\n//    - movedTo (document, oldIndex, newIndex)\n//\n// attributes available on returned query handle:\n//  * stop(): end updates\n//  * collection: the collection this query is querying\n//\n// iff x is a returned query handle, (x instanceof\n// LocalCollection.ObserveHandle) is true\n//\n// initial results delivered through added callback\n// XXX maybe callbacks should take a list of objects, to expose transactions?\n// XXX maybe support field limiting (to limit what you're notified on)\n\n_.extend(LocalCollection.Cursor.prototype, {\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */\n  observe: function (options) {\n    var self = this;\n    return LocalCollection._observeFromObserveChanges(self, options);\n  },\n\n  /**\n   * @summary Watch a query.  Receive callbacks as the result set changes.  Only the differences between the old and new documents are passed to the callbacks.\n   * @locus Anywhere\n   * @memberOf Mongo.Cursor\n   * @instance\n   * @param {Object} callbacks Functions to call to deliver the result set as it changes\n   */\n  observeChanges: function (options) {\n    var self = this;\n\n    var ordered = LocalCollection._observeChangesCallbacksAreOrdered(options);\n\n    // there are several places that assume you aren't combining skip/limit with\n    // unordered observe.  eg, update's EJSON.clone, and the \"there are several\"\n    // comment in _modifyAndNotify\n    // XXX allow skip/limit with unordered observe\n    if (!options._allow_unordered && !ordered && (self.skip || self.limit))\n      throw new Error(\"must use ordered observe (ie, 'addedBefore' instead of 'added') with skip or limit\");\n\n    if (self.fields && (self.fields._id === 0 || self.fields._id === false))\n      throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n\n    var query = {\n      dirty: false,\n      matcher: self.matcher, // not fast pathed\n      sorter: ordered && self.sorter,\n      distances: (\n        self.matcher.hasGeoQuery() && ordered && new LocalCollection._IdMap),\n      resultsSnapshot: null,\n      ordered: ordered,\n      cursor: self,\n      projectionFn: self._projectionFn\n    };\n    var qid;\n\n    // Non-reactive queries call added[Before] and then never call anything\n    // else.\n    if (self.reactive) {\n      qid = self.collection.next_qid++;\n      self.collection.queries[qid] = query;\n    }\n    query.results = self._getRawObjects({\n      ordered: ordered, distances: query.distances});\n    if (self.collection.paused)\n      query.resultsSnapshot = (ordered ? [] : new LocalCollection._IdMap);\n\n    // wrap callbacks we were passed. callbacks only fire when not paused and\n    // are never undefined\n    // Filters out blacklisted fields according to cursor's projection.\n    // XXX wrong place for this?\n\n    // furthermore, callbacks enqueue until the operation we're working on is\n    // done.\n    var wrapCallback = function (f) {\n      if (!f)\n        return function () {};\n      return function (/*args*/) {\n        var context = this;\n        var args = arguments;\n\n        if (self.collection.paused)\n          return;\n\n        self.collection._observeQueue.queueTask(function () {\n          f.apply(context, args);\n        });\n      };\n    };\n    query.added = wrapCallback(options.added);\n    query.changed = wrapCallback(options.changed);\n    query.removed = wrapCallback(options.removed);\n    if (ordered) {\n      query.addedBefore = wrapCallback(options.addedBefore);\n      query.movedBefore = wrapCallback(options.movedBefore);\n    }\n\n    if (!options._suppress_initial && !self.collection.paused) {\n      // XXX unify ordered and unordered interface\n      var each = ordered\n            ? _.bind(_.each, null, query.results)\n            : _.bind(query.results.forEach, query.results);\n      each(function (doc) {\n        var fields = EJSON.clone(doc);\n\n        delete fields._id;\n        if (ordered)\n          query.addedBefore(doc._id, self._projectionFn(fields), null);\n        query.added(doc._id, self._projectionFn(fields));\n      });\n    }\n\n    var handle = new LocalCollection.ObserveHandle;\n    _.extend(handle, {\n      collection: self.collection,\n      stop: function () {\n        if (self.reactive)\n          delete self.collection.queries[qid];\n      }\n    });\n\n    if (self.reactive && Tracker.active) {\n      // XXX in many cases, the same observe will be recreated when\n      // the current autorun is rerun.  we could save work by\n      // letting it linger across rerun and potentially get\n      // repurposed if the same observe is performed, using logic\n      // similar to that of Meteor.subscribe.\n      Tracker.onInvalidate(function () {\n        handle.stop();\n      });\n    }\n    // run the observe callbacks resulting from the initial contents\n    // before we leave the observe.\n    self.collection._observeQueue.drain();\n\n    return handle;\n  }\n});\n\n// Returns a collection of matching objects, but doesn't deep copy them.\n//\n// If ordered is set, returns a sorted array, respecting sorter, skip, and limit\n// properties of the query.  if sorter is falsey, no sort -- you get the natural\n// order.\n//\n// If ordered is not set, returns an object mapping from ID to doc (sorter, skip\n// and limit should not be set).\n//\n// If ordered is set and this cursor is a $near geoquery, then this function\n// will use an _IdMap to track each distance from the $near argument point in\n// order to use it as a sort key. If an _IdMap is passed in the 'distances'\n// argument, this function will clear it and use it for this purpose (otherwise\n// it will just create its own _IdMap). The observeChanges implementation uses\n// this to remember the distances after this function returns.\nLocalCollection.Cursor.prototype._getRawObjects = function (options) {\n  var self = this;\n  options = options || {};\n\n  // XXX use OrderedDict instead of array, and make IdMap and OrderedDict\n  // compatible\n  var results = options.ordered ? [] : new LocalCollection._IdMap;\n\n  // fast path for single ID value\n  if (self._selectorId !== undefined) {\n    // If you have non-zero skip and ask for a single id, you get\n    // nothing. This is so it matches the behavior of the '{_id: foo}'\n    // path.\n    if (self.skip)\n      return results;\n\n    var selectedDoc = self.collection._docs.get(self._selectorId);\n    if (selectedDoc) {\n      if (options.ordered)\n        results.push(selectedDoc);\n      else\n        results.set(self._selectorId, selectedDoc);\n    }\n    return results;\n  }\n\n  // slow path for arbitrary selector, sort, skip, limit\n\n  // in the observeChanges case, distances is actually part of the \"query\" (ie,\n  // live results set) object.  in other cases, distances is only used inside\n  // this function.\n  var distances;\n  if (self.matcher.hasGeoQuery() && options.ordered) {\n    if (options.distances) {\n      distances = options.distances;\n      distances.clear();\n    } else {\n      distances = new LocalCollection._IdMap();\n    }\n  }\n\n  self.collection._docs.forEach(function (doc, id) {\n    var matchResult = self.matcher.documentMatches(doc);\n    if (matchResult.result) {\n      if (options.ordered) {\n        results.push(doc);\n        if (distances && matchResult.distance !== undefined)\n          distances.set(id, matchResult.distance);\n      } else {\n        results.set(id, doc);\n      }\n    }\n    // Fast path for limited unsorted queries.\n    // XXX 'length' check here seems wrong for ordered\n    if (self.limit && !self.skip && !self.sorter &&\n        results.length === self.limit)\n      return false;  // break\n    return true;  // continue\n  });\n\n  if (!options.ordered)\n    return results;\n\n  if (self.sorter) {\n    var comparator = self.sorter.getComparator({distances: distances});\n    results.sort(comparator);\n  }\n\n  var idx_start = self.skip || 0;\n  var idx_end = self.limit ? (self.limit + idx_start) : results.length;\n  return results.slice(idx_start, idx_end);\n};\n\n// XXX Maybe we need a version of observe that just calls a callback if\n// anything changed.\nLocalCollection.Cursor.prototype._depend = function (changers, _allow_unordered) {\n  var self = this;\n\n  if (Tracker.active) {\n    var v = new Tracker.Dependency;\n    v.depend();\n    var notifyChange = _.bind(v.changed, v);\n\n    var options = {\n      _suppress_initial: true,\n      _allow_unordered: _allow_unordered\n    };\n    _.each(['added', 'changed', 'removed', 'addedBefore', 'movedBefore'],\n           function (fnName) {\n             if (changers[fnName])\n               options[fnName] = notifyChange;\n           });\n\n    // observeChanges will stop() when this computation is invalidated\n    self.observeChanges(options);\n  }\n};\n\n// XXX possibly enforce that 'undefined' does not appear (we assume\n// this in our handling of null and $exists)\nLocalCollection.prototype.insert = function (doc, callback) {\n  var self = this;\n  doc = EJSON.clone(doc);\n\n  assertHasValidFieldNames(doc);\n\n  if (!_.has(doc, '_id')) {\n    // if you really want to use ObjectIDs, set this global.\n    // Mongo.Collection specifies its own ids and does not use this code.\n    doc._id = LocalCollection._useOID ? new MongoID.ObjectID()\n                                      : Random.id();\n  }\n  var id = doc._id;\n\n  if (self._docs.has(id))\n    throw MinimongoError(\"Duplicate _id '\" + id + \"'\");\n\n  self._saveOriginal(id, undefined);\n  self._docs.set(id, doc);\n\n  var queriesToRecompute = [];\n  // trigger live queries that match\n  for (var qid in self.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n    var matchResult = query.matcher.documentMatches(doc);\n    if (matchResult.result) {\n      if (query.distances && matchResult.distance !== undefined)\n        query.distances.set(id, matchResult.distance);\n      if (query.cursor.skip || query.cursor.limit)\n        queriesToRecompute.push(qid);\n      else\n        LocalCollection._insertInResults(query, doc);\n    }\n  }\n\n  _.each(queriesToRecompute, function (qid) {\n    if (self.queries[qid])\n      self._recomputeResults(self.queries[qid]);\n  });\n  self._observeQueue.drain();\n\n  // Defer because the caller likely doesn't expect the callback to be run\n  // immediately.\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, id);\n    });\n  return id;\n};\n\n// Iterates over a subset of documents that could match selector; calls\n// f(doc, id) on each of them.  Specifically, if selector specifies\n// specific _id's, it only looks at those.  doc is *not* cloned: it is the\n// same object that is in _docs.\nLocalCollection.prototype._eachPossiblyMatchingDoc = function (selector, f) {\n  var self = this;\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    for (var i = 0; i < specificIds.length; ++i) {\n      var id = specificIds[i];\n      var doc = self._docs.get(id);\n      if (doc) {\n        var breakIfFalse = f(doc, id);\n        if (breakIfFalse === false)\n          break;\n      }\n    }\n  } else {\n    self._docs.forEach(f);\n  }\n};\n\nLocalCollection.prototype.remove = function (selector, callback) {\n  var self = this;\n\n  // Easy special case: if we're not calling observeChanges callbacks and we're\n  // not saving originals and we got asked to remove everything, then just empty\n  // everything directly.\n  if (self.paused && !self._savedOriginals && EJSON.equals(selector, {})) {\n    var result = self._docs.size();\n    self._docs.clear();\n    _.each(self.queries, function (query) {\n      if (query.ordered) {\n        query.results = [];\n      } else {\n        query.results.clear();\n      }\n    });\n    if (callback) {\n      Meteor.defer(function () {\n        callback(null, result);\n      });\n    }\n    return result;\n  }\n\n  var matcher = new Minimongo.Matcher(selector);\n  var remove = [];\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    if (matcher.documentMatches(doc).result)\n      remove.push(id);\n  });\n\n  var queriesToRecompute = [];\n  var queryRemove = [];\n  for (var i = 0; i < remove.length; i++) {\n    var removeId = remove[i];\n    var removeDoc = self._docs.get(removeId);\n    _.each(self.queries, function (query, qid) {\n      if (query.dirty) return;\n\n      if (query.matcher.documentMatches(removeDoc).result) {\n        if (query.cursor.skip || query.cursor.limit)\n          queriesToRecompute.push(qid);\n        else\n          queryRemove.push({qid: qid, doc: removeDoc});\n      }\n    });\n    self._saveOriginal(removeId, removeDoc);\n    self._docs.remove(removeId);\n  }\n\n  // run live query callbacks _after_ we've removed the documents.\n  _.each(queryRemove, function (remove) {\n    var query = self.queries[remove.qid];\n    if (query) {\n      query.distances && query.distances.remove(remove.doc._id);\n      LocalCollection._removeFromResults(query, remove.doc);\n    }\n  });\n  _.each(queriesToRecompute, function (qid) {\n    var query = self.queries[qid];\n    if (query)\n      self._recomputeResults(query);\n  });\n  self._observeQueue.drain();\n  result = remove.length;\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, result);\n    });\n  return result;\n};\n\n// XXX atomicity: if multi is true, and one modification fails, do\n// we rollback the whole operation, or what?\nLocalCollection.prototype.update = function (selector, mod, options, callback) {\n  var self = this;\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n  if (!options) options = {};\n\n  var matcher = new Minimongo.Matcher(selector);\n\n  // Save the original results of any query that we might need to\n  // _recomputeResults on, because _modifyAndNotify will mutate the objects in\n  // it. (We don't need to save the original results of paused queries because\n  // they already have a resultsSnapshot and we won't be diffing in\n  // _recomputeResults.)\n  var qidToOriginalResults = {};\n  // We should only clone each document once, even if it appears in multiple queries\n  var docMap = new LocalCollection._IdMap;\n  var idsMatchedBySelector = LocalCollection._idsMatchedBySelector(selector);\n\n  _.each(self.queries, function (query, qid) {\n    if ((query.cursor.skip || query.cursor.limit) && ! self.paused) {\n      // Catch the case of a reactive `count()` on a cursor with skip\n      // or limit, which registers an unordered observe. This is a\n      // pretty rare case, so we just clone the entire result set with\n      // no optimizations for documents that appear in these result\n      // sets and other queries.\n      if (query.results instanceof LocalCollection._IdMap) {\n        qidToOriginalResults[qid] = query.results.clone();\n        return;\n      }\n\n      if (!(query.results instanceof Array)) {\n        throw new Error(\"Assertion failed: query.results not an array\");\n      }\n\n      // Clones a document to be stored in `qidToOriginalResults`\n      // because it may be modified before the new and old result sets\n      // are diffed. But if we know exactly which document IDs we're\n      // going to modify, then we only need to clone those.\n      var memoizedCloneIfNeeded = function(doc) {\n        if (docMap.has(doc._id)) {\n          return docMap.get(doc._id);\n        } else {\n          var docToMemoize;\n\n          if (idsMatchedBySelector && !_.any(idsMatchedBySelector, function(id) {\n            return EJSON.equals(id, doc._id);\n          })) {\n            docToMemoize = doc;\n          } else {\n            docToMemoize = EJSON.clone(doc);\n          }\n\n          docMap.set(doc._id, docToMemoize);\n          return docToMemoize;\n        }\n      };\n\n      qidToOriginalResults[qid] = query.results.map(memoizedCloneIfNeeded);\n    }\n  });\n  var recomputeQids = {};\n\n  var updateCount = 0;\n\n  self._eachPossiblyMatchingDoc(selector, function (doc, id) {\n    var queryResult = matcher.documentMatches(doc);\n    if (queryResult.result) {\n      // XXX Should we save the original even if mod ends up being a no-op?\n      self._saveOriginal(id, doc);\n      self._modifyAndNotify(doc, mod, recomputeQids, queryResult.arrayIndices);\n      ++updateCount;\n      if (!options.multi)\n        return false;  // break\n    }\n    return true;\n  });\n\n  _.each(recomputeQids, function (dummy, qid) {\n    var query = self.queries[qid];\n    if (query)\n      self._recomputeResults(query, qidToOriginalResults[qid]);\n  });\n  self._observeQueue.drain();\n\n  // If we are doing an upsert, and we didn't modify any documents yet, then\n  // it's time to do an insert. Figure out what document we are inserting, and\n  // generate an id for it.\n  var insertedId;\n  if (updateCount === 0 && options.upsert) {\n    var newDoc = LocalCollection._removeDollarOperators(selector);\n    LocalCollection._modify(newDoc, mod, {isInsert: true});\n    if (! newDoc._id && options.insertedId)\n      newDoc._id = options.insertedId;\n    insertedId = self.insert(newDoc);\n    updateCount = 1;\n  }\n\n  // Return the number of affected documents, or in the upsert case, an object\n  // containing the number of affected docs and the id of the doc that was\n  // inserted, if any.\n  var result;\n  if (options._returnObject) {\n    result = {\n      numberAffected: updateCount\n    };\n    if (insertedId !== undefined)\n      result.insertedId = insertedId;\n  } else {\n    result = updateCount;\n  }\n\n  if (callback)\n    Meteor.defer(function () {\n      callback(null, result);\n    });\n  return result;\n};\n\n// A convenience wrapper on update. LocalCollection.upsert(sel, mod) is\n// equivalent to LocalCollection.update(sel, mod, { upsert: true, _returnObject:\n// true }).\nLocalCollection.prototype.upsert = function (selector, mod, options, callback) {\n  var self = this;\n  if (! callback && typeof options === \"function\") {\n    callback = options;\n    options = {};\n  }\n  return self.update(selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nLocalCollection.prototype._modifyAndNotify = function (\n    doc, mod, recomputeQids, arrayIndices) {\n  var self = this;\n\n  var matched_before = {};\n  for (var qid in self.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) continue;\n\n    if (query.ordered) {\n      matched_before[qid] = query.matcher.documentMatches(doc).result;\n    } else {\n      // Because we don't support skip or limit (yet) in unordered queries, we\n      // can just do a direct lookup.\n      matched_before[qid] = query.results.has(doc._id);\n    }\n  }\n\n  var old_doc = EJSON.clone(doc);\n\n  LocalCollection._modify(doc, mod, {arrayIndices: arrayIndices});\n\n  for (qid in self.queries) {\n    query = self.queries[qid];\n    if (query.dirty) continue;\n\n    var before = matched_before[qid];\n    var afterMatch = query.matcher.documentMatches(doc);\n    var after = afterMatch.result;\n    if (after && query.distances && afterMatch.distance !== undefined)\n      query.distances.set(doc._id, afterMatch.distance);\n\n    if (query.cursor.skip || query.cursor.limit) {\n      // We need to recompute any query where the doc may have been in the\n      // cursor's window either before or after the update. (Note that if skip\n      // or limit is set, \"before\" and \"after\" being true do not necessarily\n      // mean that the document is in the cursor's output after skip/limit is\n      // applied... but if they are false, then the document definitely is NOT\n      // in the output. So it's safe to skip recompute if neither before or\n      // after are true.)\n      if (before || after)\n        recomputeQids[qid] = true;\n    } else if (before && !after) {\n      LocalCollection._removeFromResults(query, doc);\n    } else if (!before && after) {\n      LocalCollection._insertInResults(query, doc);\n    } else if (before && after) {\n      LocalCollection._updateInResults(query, doc, old_doc);\n    }\n  }\n};\n\n// XXX the sorted-query logic below is laughably inefficient. we'll\n// need to come up with a better datastructure for this.\n//\n// XXX the logic for observing with a skip or a limit is even more\n// laughably inefficient. we recompute the whole results every time!\n\nLocalCollection._insertInResults = function (query, doc) {\n  var fields = EJSON.clone(doc);\n  delete fields._id;\n  if (query.ordered) {\n    if (!query.sorter) {\n      query.addedBefore(doc._id, query.projectionFn(fields), null);\n      query.results.push(doc);\n    } else {\n      var i = LocalCollection._insertInSortedList(\n        query.sorter.getComparator({distances: query.distances}),\n        query.results, doc);\n      var next = query.results[i+1];\n      if (next)\n        next = next._id;\n      else\n        next = null;\n      query.addedBefore(doc._id, query.projectionFn(fields), next);\n    }\n    query.added(doc._id, query.projectionFn(fields));\n  } else {\n    query.added(doc._id, query.projectionFn(fields));\n    query.results.set(doc._id, doc);\n  }\n};\n\nLocalCollection._removeFromResults = function (query, doc) {\n  if (query.ordered) {\n    var i = LocalCollection._findInOrderedResults(query, doc);\n    query.removed(doc._id);\n    query.results.splice(i, 1);\n  } else {\n    var id = doc._id;  // in case callback mutates doc\n    query.removed(doc._id);\n    query.results.remove(id);\n  }\n};\n\nLocalCollection._updateInResults = function (query, doc, old_doc) {\n  if (!EJSON.equals(doc._id, old_doc._id))\n    throw new Error(\"Can't change a doc's _id while updating\");\n  var projectionFn = query.projectionFn;\n  var changedFields = DiffSequence.makeChangedFields(\n    projectionFn(doc), projectionFn(old_doc));\n\n  if (!query.ordered) {\n    if (!_.isEmpty(changedFields)) {\n      query.changed(doc._id, changedFields);\n      query.results.set(doc._id, doc);\n    }\n    return;\n  }\n\n  var orig_idx = LocalCollection._findInOrderedResults(query, doc);\n\n  if (!_.isEmpty(changedFields))\n    query.changed(doc._id, changedFields);\n  if (!query.sorter)\n    return;\n\n  // just take it out and put it back in again, and see if the index\n  // changes\n  query.results.splice(orig_idx, 1);\n  var new_idx = LocalCollection._insertInSortedList(\n    query.sorter.getComparator({distances: query.distances}),\n    query.results, doc);\n  if (orig_idx !== new_idx) {\n    var next = query.results[new_idx+1];\n    if (next)\n      next = next._id;\n    else\n      next = null;\n    query.movedBefore && query.movedBefore(doc._id, next);\n  }\n};\n\n// Recomputes the results of a query and runs observe callbacks for the\n// difference between the previous results and the current results (unless\n// paused). Used for skip/limit queries.\n//\n// When this is used by insert or remove, it can just use query.results for the\n// old results (and there's no need to pass in oldResults), because these\n// operations don't mutate the documents in the collection. Update needs to pass\n// in an oldResults which was deep-copied before the modifier was applied.\n//\n// oldResults is guaranteed to be ignored if the query is not paused.\nLocalCollection.prototype._recomputeResults = function (query, oldResults) {\n  var self = this;\n  if (self.paused) {\n    // There's no reason to recompute the results now as we're still paused.\n    // By flagging the query as \"dirty\", the recompute will be performed\n    // when resumeObservers is called.\n    query.dirty = true;\n    return;\n  }\n\n  if (! self.paused && ! oldResults)\n    oldResults = query.results;\n  if (query.distances)\n    query.distances.clear();\n  query.results = query.cursor._getRawObjects({\n    ordered: query.ordered, distances: query.distances});\n\n  if (! self.paused) {\n    LocalCollection._diffQueryChanges(\n      query.ordered, oldResults, query.results, query,\n      { projectionFn: query.projectionFn });\n  }\n};\n\n\nLocalCollection._findInOrderedResults = function (query, doc) {\n  if (!query.ordered)\n    throw new Error(\"Can't call _findInOrderedResults on unordered query\");\n  for (var i = 0; i < query.results.length; i++)\n    if (query.results[i] === doc)\n      return i;\n  throw Error(\"object missing from query\");\n};\n\n// This binary search puts a value between any equal values, and the first\n// lesser value.\nLocalCollection._binarySearch = function (cmp, array, value) {\n  var first = 0, rangeLength = array.length;\n\n  while (rangeLength > 0) {\n    var halfRange = Math.floor(rangeLength/2);\n    if (cmp(value, array[first + halfRange]) >= 0) {\n      first += halfRange + 1;\n      rangeLength -= halfRange + 1;\n    } else {\n      rangeLength = halfRange;\n    }\n  }\n  return first;\n};\n\nLocalCollection._insertInSortedList = function (cmp, array, value) {\n  if (array.length === 0) {\n    array.push(value);\n    return 0;\n  }\n\n  var idx = LocalCollection._binarySearch(cmp, array, value);\n  array.splice(idx, 0, value);\n  return idx;\n};\n\n// To track what documents are affected by a piece of code, call saveOriginals()\n// before it and retrieveOriginals() after it. retrieveOriginals returns an\n// object whose keys are the ids of the documents that were affected since the\n// call to saveOriginals(), and the values are equal to the document's contents\n// at the time of saveOriginals. (In the case of an inserted document, undefined\n// is the value.) You must alternate between calls to saveOriginals() and\n// retrieveOriginals().\nLocalCollection.prototype.saveOriginals = function () {\n  var self = this;\n  if (self._savedOriginals)\n    throw new Error(\"Called saveOriginals twice without retrieveOriginals\");\n  self._savedOriginals = new LocalCollection._IdMap;\n};\nLocalCollection.prototype.retrieveOriginals = function () {\n  var self = this;\n  if (!self._savedOriginals)\n    throw new Error(\"Called retrieveOriginals without saveOriginals\");\n\n  var originals = self._savedOriginals;\n  self._savedOriginals = null;\n  return originals;\n};\n\nLocalCollection.prototype._saveOriginal = function (id, doc) {\n  var self = this;\n  // Are we even trying to save originals?\n  if (!self._savedOriginals)\n    return;\n  // Have we previously mutated the original (and so 'doc' is not actually\n  // original)?  (Note the 'has' check rather than truth: we store undefined\n  // here for inserted docs!)\n  if (self._savedOriginals.has(id))\n    return;\n  self._savedOriginals.set(id, EJSON.clone(doc));\n};\n\n// Pause the observers. No callbacks from observers will fire until\n// 'resumeObservers' is called.\nLocalCollection.prototype.pauseObservers = function () {\n  // No-op if already paused.\n  if (this.paused)\n    return;\n\n  // Set the 'paused' flag such that new observer messages don't fire.\n  this.paused = true;\n\n  // Take a snapshot of the query results for each query.\n  for (var qid in this.queries) {\n    var query = this.queries[qid];\n\n    query.resultsSnapshot = EJSON.clone(query.results);\n  }\n};\n\n// Resume the observers. Observers immediately receive change\n// notifications to bring them to the current state of the\n// database. Note that this is not just replaying all the changes that\n// happened during the pause, it is a smarter 'coalesced' diff.\nLocalCollection.prototype.resumeObservers = function () {\n  var self = this;\n  // No-op if not paused.\n  if (!this.paused)\n    return;\n\n  // Unset the 'paused' flag. Make sure to do this first, otherwise\n  // observer methods won't actually fire when we trigger them.\n  this.paused = false;\n\n  for (var qid in this.queries) {\n    var query = self.queries[qid];\n    if (query.dirty) {\n      query.dirty = false;\n      // re-compute results will perform `LocalCollection._diffQueryChanges` automatically.\n      self._recomputeResults(query, query.resultsSnapshot);\n    } else {\n      // Diff the current results against the snapshot and send to observers.\n      // pass the query object for its observer callbacks.\n      LocalCollection._diffQueryChanges(\n        query.ordered, query.resultsSnapshot, query.results, query,\n        {projectionFn: query.projectionFn});\n    }\n    query.resultsSnapshot = null;\n  }\n  self._observeQueue.drain();\n};\n"]},"hash":"14bd945174c3da784672a02bac09104916ebd443"}
