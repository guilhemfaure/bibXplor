{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/projection.js","filenameRelative":"/packages/minimongo/projection.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/projection.js.map","sourceFileName":"/packages/minimongo/projection.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"projection"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\n// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = function (fields) {\n  LocalCollection._checkSupportedProjection(fields);\n\n  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;\n\n  var details = projectionDetails(fields); // returns transformed doc according to ruleTree\n\n  var transform = function (doc, ruleTree) {\n    // Special case for \"sets\"\n    if (_.isArray(doc)) return _.map(doc, function (subdoc) {\n      return transform(subdoc, ruleTree);\n    });\n    var res = details.including ? {} : EJSON.clone(doc);\n\n    _.each(ruleTree, function (rule, key) {\n      if (!_.has(doc, key)) return;\n\n      if (_.isObject(rule)) {\n        // For sub-objects/subsets we branch\n        if (_.isObject(doc[key])) res[key] = transform(doc[key], rule); // Otherwise we don't even touch this subfield\n      } else if (details.including) res[key] = EJSON.clone(doc[key]);else delete res[key];\n    });\n\n    return res;\n  };\n\n  return function (obj) {\n    var res = transform(obj, details.tree);\n    if (_idProjection && _.has(obj, '_id')) res._id = obj._id;\n    if (!_idProjection && _.has(res, '_id')) delete res._id;\n    return res;\n  };\n}; // Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - \"take only certain fields\" type of projection\n\n\nprojectionDetails = function (fields) {\n  // Find the non-_id keys (_id is handled specially because it is included unless\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  var fieldsKeys = _.keys(fields).sort(); // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n\n\n  if (fieldsKeys.length > 0 && !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') && !(_.contains(fieldsKeys, '_id') && fields['_id'])) fieldsKeys = _.reject(fieldsKeys, function (key) {\n    return key === '_id';\n  });\n  var including = null; // Unknown\n\n  _.each(fieldsKeys, function (keyPath) {\n    var rule = !!fields[keyPath];\n    if (including === null) including = rule;\n    if (including !== rule) // This error message is copied from MongoDB shell\n      throw MinimongoError(\"You cannot currently mix including and excluding fields.\");\n  });\n\n  var projectionRulesTree = pathsToTree(fieldsKeys, function (path) {\n    return including;\n  }, function (node, path, fullPath) {\n    // Check passed projection fields' keys: If you have two rules such as\n    // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n    // that happens, there is a probability you are doing something wrong,\n    // framework should notify you about such mistake earlier on cursor\n    // compilation step than later during runtime.  Note, that real mongo\n    // doesn't do anything about it and the later rule appears in projection\n    // project, more priority it takes.\n    //\n    // Example, assume following in mongo shell:\n    // > db.coll.insert({ a: { b: 23, c: 44 } })\n    // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n    // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23 } }\n    // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n    // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23, \"c\" : 44 } }\n    //\n    // Note, how second time the return set of keys is different.\n    var currentPath = fullPath;\n    var anotherPath = path;\n    throw MinimongoError(\"both \" + currentPath + \" and \" + anotherPath + \" found in fields option, using both of them may trigger \" + \"unexpected behavior. Did you mean to use only one of them?\");\n  });\n  return {\n    tree: projectionRulesTree,\n    including: including\n  };\n}; // paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\n\n\npathsToTree = function (paths, newLeafFn, conflictFn, tree) {\n  tree = tree || {};\n\n  _.each(paths, function (keyPath) {\n    var treePos = tree;\n    var pathArr = keyPath.split('.'); // use _.all just for iteration with break\n\n    var success = _.all(pathArr.slice(0, -1), function (key, idx) {\n      if (!_.has(treePos, key)) treePos[key] = {};else if (!_.isObject(treePos[key])) {\n        treePos[key] = conflictFn(treePos[key], pathArr.slice(0, idx + 1).join('.'), keyPath); // break out of loop if we are failing for this path\n\n        if (!_.isObject(treePos[key])) return false;\n      }\n      treePos = treePos[key];\n      return true;\n    });\n\n    if (success) {\n      var lastKey = _.last(pathArr);\n\n      if (!_.has(treePos, lastKey)) treePos[lastKey] = newLeafFn(keyPath);else treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);\n    }\n  });\n\n  return tree;\n};\n\nLocalCollection._checkSupportedProjection = function (fields) {\n  if (!_.isObject(fields) || _.isArray(fields)) throw MinimongoError(\"fields option must be an object\");\n\n  _.each(fields, function (val, keyPath) {\n    if (_.contains(keyPath.split('.'), '$')) throw MinimongoError(\"Minimongo doesn't support $ operator in projections yet.\");\n    if ((typeof val === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(val)) === 'object' && _.intersection(['$elemMatch', '$meta', '$slice'], _.keys(val)).length > 0) throw MinimongoError(\"Minimongo doesn't support operators in projections yet.\");\n    if (_.indexOf([1, 0, true, false], val) === -1) throw MinimongoError(\"Projection values should be one of 1, 0, true, or false\");\n  });\n};","map":{"version":3,"sources":["/packages/minimongo/projection.js"],"names":["LocalCollection","_compileProjection","fields","_checkSupportedProjection","_idProjection","_","isUndefined","_id","details","projectionDetails","transform","doc","ruleTree","isArray","map","subdoc","res","including","EJSON","clone","each","rule","key","has","isObject","obj","tree","fieldsKeys","keys","sort","length","contains","reject","keyPath","MinimongoError","projectionRulesTree","pathsToTree","path","node","fullPath","currentPath","anotherPath","paths","newLeafFn","conflictFn","treePos","pathArr","split","success","all","slice","idx","join","lastKey","last","val","intersection","indexOf"],"mappings":"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","file":"/packages/minimongo/projection.js.map","sourcesContent":["// Knows how to compile a fields projection to a predicate function.\n// @returns - Function: a closure that filters out an object according to the\n//            fields projection rules:\n//            @param obj - Object: MongoDB-styled document\n//            @returns - Object: a document with the fields filtered out\n//                       according to projection rules. Doesn't retain subfields\n//                       of passed argument.\nLocalCollection._compileProjection = function (fields) {\n  LocalCollection._checkSupportedProjection(fields);\n\n  var _idProjection = _.isUndefined(fields._id) ? true : fields._id;\n  var details = projectionDetails(fields);\n\n  // returns transformed doc according to ruleTree\n  var transform = function (doc, ruleTree) {\n    // Special case for \"sets\"\n    if (_.isArray(doc))\n      return _.map(doc, function (subdoc) { return transform(subdoc, ruleTree); });\n\n    var res = details.including ? {} : EJSON.clone(doc);\n    _.each(ruleTree, function (rule, key) {\n      if (!_.has(doc, key))\n        return;\n      if (_.isObject(rule)) {\n        // For sub-objects/subsets we branch\n        if (_.isObject(doc[key]))\n          res[key] = transform(doc[key], rule);\n        // Otherwise we don't even touch this subfield\n      } else if (details.including)\n        res[key] = EJSON.clone(doc[key]);\n      else\n        delete res[key];\n    });\n\n    return res;\n  };\n\n  return function (obj) {\n    var res = transform(obj, details.tree);\n\n    if (_idProjection && _.has(obj, '_id'))\n      res._id = obj._id;\n    if (!_idProjection && _.has(res, '_id'))\n      delete res._id;\n    return res;\n  };\n};\n\n// Traverses the keys of passed projection and constructs a tree where all\n// leaves are either all True or all False\n// @returns Object:\n//  - tree - Object - tree representation of keys involved in projection\n//  (exception for '_id' as it is a special case handled separately)\n//  - including - Boolean - \"take only certain fields\" type of projection\nprojectionDetails = function (fields) {\n  // Find the non-_id keys (_id is handled specially because it is included unless\n  // explicitly excluded). Sort the keys, so that our code to detect overlaps\n  // like 'foo' and 'foo.bar' can assume that 'foo' comes first.\n  var fieldsKeys = _.keys(fields).sort();\n\n  // If _id is the only field in the projection, do not remove it, since it is\n  // required to determine if this is an exclusion or exclusion. Also keep an\n  // inclusive _id, since inclusive _id follows the normal rules about mixing\n  // inclusive and exclusive fields. If _id is not the only field in the\n  // projection and is exclusive, remove it so it can be handled later by a\n  // special case, since exclusive _id is always allowed.\n  if (fieldsKeys.length > 0 &&\n      !(fieldsKeys.length === 1 && fieldsKeys[0] === '_id') &&\n      !(_.contains(fieldsKeys, '_id') && fields['_id']))\n    fieldsKeys = _.reject(fieldsKeys, function (key) { return key === '_id'; });\n\n  var including = null; // Unknown\n\n  _.each(fieldsKeys, function (keyPath) {\n    var rule = !!fields[keyPath];\n    if (including === null)\n      including = rule;\n    if (including !== rule)\n      // This error message is copied from MongoDB shell\n      throw MinimongoError(\"You cannot currently mix including and excluding fields.\");\n  });\n\n\n  var projectionRulesTree = pathsToTree(\n    fieldsKeys,\n    function (path) { return including; },\n    function (node, path, fullPath) {\n      // Check passed projection fields' keys: If you have two rules such as\n      // 'foo.bar' and 'foo.bar.baz', then the result becomes ambiguous. If\n      // that happens, there is a probability you are doing something wrong,\n      // framework should notify you about such mistake earlier on cursor\n      // compilation step than later during runtime.  Note, that real mongo\n      // doesn't do anything about it and the later rule appears in projection\n      // project, more priority it takes.\n      //\n      // Example, assume following in mongo shell:\n      // > db.coll.insert({ a: { b: 23, c: 44 } })\n      // > db.coll.find({}, { 'a': 1, 'a.b': 1 })\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23 } }\n      // > db.coll.find({}, { 'a.b': 1, 'a': 1 })\n      // { \"_id\" : ObjectId(\"520bfe456024608e8ef24af3\"), \"a\" : { \"b\" : 23, \"c\" : 44 } }\n      //\n      // Note, how second time the return set of keys is different.\n\n      var currentPath = fullPath;\n      var anotherPath = path;\n      throw MinimongoError(\"both \" + currentPath + \" and \" + anotherPath +\n                           \" found in fields option, using both of them may trigger \" +\n                           \"unexpected behavior. Did you mean to use only one of them?\");\n    });\n\n  return {\n    tree: projectionRulesTree,\n    including: including\n  };\n};\n\n// paths - Array: list of mongo style paths\n// newLeafFn - Function: of form function(path) should return a scalar value to\n//                       put into list created for that path\n// conflictFn - Function: of form function(node, path, fullPath) is called\n//                        when building a tree path for 'fullPath' node on\n//                        'path' was already a leaf with a value. Must return a\n//                        conflict resolution.\n// initial tree - Optional Object: starting tree.\n// @returns - Object: tree represented as a set of nested objects\npathsToTree = function (paths, newLeafFn, conflictFn, tree) {\n  tree = tree || {};\n  _.each(paths, function (keyPath) {\n    var treePos = tree;\n    var pathArr = keyPath.split('.');\n\n    // use _.all just for iteration with break\n    var success = _.all(pathArr.slice(0, -1), function (key, idx) {\n      if (!_.has(treePos, key))\n        treePos[key] = {};\n      else if (!_.isObject(treePos[key])) {\n        treePos[key] = conflictFn(treePos[key],\n                                  pathArr.slice(0, idx + 1).join('.'),\n                                  keyPath);\n        // break out of loop if we are failing for this path\n        if (!_.isObject(treePos[key]))\n          return false;\n      }\n\n      treePos = treePos[key];\n      return true;\n    });\n\n    if (success) {\n      var lastKey = _.last(pathArr);\n      if (!_.has(treePos, lastKey))\n        treePos[lastKey] = newLeafFn(keyPath);\n      else\n        treePos[lastKey] = conflictFn(treePos[lastKey], keyPath, keyPath);\n    }\n  });\n\n  return tree;\n};\n\nLocalCollection._checkSupportedProjection = function (fields) {\n  if (!_.isObject(fields) || _.isArray(fields))\n    throw MinimongoError(\"fields option must be an object\");\n\n  _.each(fields, function (val, keyPath) {\n    if (_.contains(keyPath.split('.'), '$'))\n      throw MinimongoError(\"Minimongo doesn't support $ operator in projections yet.\");\n    if (typeof val === 'object' && _.intersection(['$elemMatch', '$meta', '$slice'], _.keys(val)).length > 0)\n      throw MinimongoError(\"Minimongo doesn't support operators in projections yet.\");\n    if (_.indexOf([1, 0, true, false], val) === -1)\n      throw MinimongoError(\"Projection values should be one of 1, 0, true, or false\");\n  });\n};\n"]},"hash":"eced1456e71c37a587d77d42c903d3a49174207c"}
