{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/minimongo_server_tests.js","filenameRelative":"/packages/minimongo/minimongo_server_tests.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/minimongo_server_tests.js.map","sourceFileName":"/packages/minimongo/minimongo_server_tests.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"minimongo_server_tests"},"ignored":false,"code":"Tinytest.add(\"minimongo - modifier affects selector\", function (test) {\n  function testSelectorPaths(sel, paths, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher._getPaths(), paths, desc);\n  }\n\n  testSelectorPaths({\n    foo: {\n      bar: 3,\n      baz: 42\n    }\n  }, ['foo'], \"literal\");\n  testSelectorPaths({\n    foo: 42,\n    bar: 33\n  }, ['foo', 'bar'], \"literal\");\n  testSelectorPaths({\n    foo: ['something'],\n    bar: \"asdf\"\n  }, ['foo', 'bar'], \"literal\");\n  testSelectorPaths({\n    a: {\n      $lt: 3\n    },\n    b: \"you know, literal\",\n    'path.is.complicated': {\n      $not: {\n        $regex: 'acme.*corp'\n      }\n    }\n  }, ['a', 'b', 'path.is.complicated'], \"literal + operators\");\n  testSelectorPaths({\n    $or: [{\n      'a.b': 1\n    }, {\n      'a.b.c': {\n        $lt: 22\n      }\n    }, {\n      $and: [{\n        'x.d': {\n          $ne: 5,\n          $gte: 433\n        }\n      }, {\n        'a.b': 234\n      }]\n    }]\n  }, ['a.b', 'a.b.c', 'x.d'], 'group operators + duplicates'); // When top-level value is an object, it is treated as a literal,\n  // so when you query col.find({ a: { foo: 1, bar: 2 } })\n  // it doesn't mean you are looking for anything that has 'a.foo' to be 1 and\n  // 'a.bar' to be 2, instead you are looking for 'a' to be exatly that object\n  // with exatly that order of keys. { a: { foo: 1, bar: 2, baz: 3 } } wouldn't\n  // match it. That's why in this selector 'a' would be important key, not a.foo\n  // and a.bar.\n\n  testSelectorPaths({\n    a: {\n      foo: 1,\n      bar: 2\n    },\n    'b.c': {\n      literal: \"object\",\n      but: \"we still observe any changes in 'b.c'\"\n    }\n  }, ['a', 'b.c'], \"literal object\"); // Note that a and b do NOT end up in the path list, but x and y both do.\n\n  testSelectorPaths({\n    $or: [{\n      x: {\n        $elemMatch: {\n          a: 5\n        }\n      }\n    }, {\n      y: {\n        $elemMatch: {\n          b: 7\n        }\n      }\n    }]\n  }, ['x', 'y'], \"$or and elemMatch\");\n\n  function testSelectorAffectedByModifier(sel, mod, yes, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.affectedByModifier(mod), yes, desc);\n  }\n\n  function affected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, true, desc);\n  }\n\n  function notAffected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, false, desc);\n  }\n\n  notAffected({\n    foo: 0\n  }, {\n    $set: {\n      bar: 1\n    }\n  }, \"simplest\");\n  affected({\n    foo: 0\n  }, {\n    $set: {\n      foo: 1\n    }\n  }, \"simplest\");\n  affected({\n    foo: 0\n  }, {\n    $set: {\n      'foo.bar': 1\n    }\n  }, \"simplest\");\n  notAffected({\n    'foo.bar': 0\n  }, {\n    $set: {\n      'foo.baz': 1\n    }\n  }, \"simplest\");\n  affected({\n    'foo.bar': 0\n  }, {\n    $set: {\n      'foo.1': 1\n    }\n  }, \"simplest\");\n  affected({\n    'foo.bar': 0\n  }, {\n    $set: {\n      'foo.2.bar': 1\n    }\n  }, \"simplest\");\n  notAffected({\n    'foo': 0\n  }, {\n    $set: {\n      'foobaz': 1\n    }\n  }, \"correct prefix check\");\n  notAffected({\n    'foobar': 0\n  }, {\n    $unset: {\n      'foo': 1\n    }\n  }, \"correct prefix check\");\n  notAffected({\n    'foo.bar': 0\n  }, {\n    $unset: {\n      'foob': 1\n    }\n  }, \"correct prefix check\");\n  notAffected({\n    'foo.Infinity.x': 0\n  }, {\n    $unset: {\n      'foo.x': 1\n    }\n  }, \"we convert integer fields correctly\");\n  notAffected({\n    'foo.1e3.x': 0\n  }, {\n    $unset: {\n      'foo.x': 1\n    }\n  }, \"we convert integer fields correctly\");\n  affected({\n    'foo.3.bar': 0\n  }, {\n    $set: {\n      'foo.3.bar': 1\n    }\n  }, \"observe for an array element\");\n  notAffected({\n    'foo.4.bar.baz': 0\n  }, {\n    $unset: {\n      'foo.3.bar': 1\n    }\n  }, \"delicate work with numeric fields in selector\");\n  notAffected({\n    'foo.4.bar.baz': 0\n  }, {\n    $unset: {\n      'foo.bar': 1\n    }\n  }, \"delicate work with numeric fields in selector\");\n  affected({\n    'foo.4.bar.baz': 0\n  }, {\n    $unset: {\n      'foo.4.bar': 1\n    }\n  }, \"delicate work with numeric fields in selector\");\n  affected({\n    'foo.bar.baz': 0\n  }, {\n    $unset: {\n      'foo.3.bar': 1\n    }\n  }, \"delicate work with numeric fields in selector\");\n  affected({\n    'foo.0.bar': 0\n  }, {\n    $set: {\n      'foo.0.0.bar': 1\n    }\n  }, \"delicate work with nested arrays and selectors by indecies\");\n  affected({\n    foo: {\n      $elemMatch: {\n        bar: 5\n      }\n    }\n  }, {\n    $set: {\n      'foo.4.bar': 5\n    }\n  }, \"$elemMatch\");\n});\nTinytest.add(\"minimongo - selector and projection combination\", function (test) {\n  function testSelProjectionComb(sel, proj, expected, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.combineIntoProjection(proj), expected, desc);\n  } // Test with inclusive projection\n\n\n  testSelProjectionComb({\n    a: 1,\n    b: 2\n  }, {\n    b: 1,\n    c: 1,\n    d: 1\n  }, {\n    a: true,\n    b: true,\n    c: true,\n    d: true\n  }, \"simplest incl\");\n  testSelProjectionComb({\n    $or: [{\n      a: 1234,\n      e: {\n        $lt: 5\n      }\n    }],\n    b: 2\n  }, {\n    b: 1,\n    c: 1,\n    d: 1\n  }, {\n    a: true,\n    b: true,\n    c: true,\n    d: true,\n    e: true\n  }, \"simplest incl, branching\");\n  testSelProjectionComb({\n    'a.b': {\n      $lt: 3\n    },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 1,\n    'z': 1\n  }, {\n    'a.b': true,\n    'y': true,\n    'a.c': true,\n    'd': true,\n    'z': true\n  }, \"multikey paths in selector - incl\");\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{\n      k: -1\n    }, {\n      $or: [{\n        b: 15\n      }]\n    }]\n  }, {\n    'foo.bar': 1,\n    'foo.zzz': 1,\n    'b.asdf': 1\n  }, {\n    foo: true,\n    b: true,\n    k: true\n  }, \"multikey paths in fields - incl\");\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 1,\n    'a.b.d.g': 1,\n    'c.c.c': 1\n  }, {\n    'a.b.c': true,\n    'a.b.d': true,\n    'a.b.z': true,\n    'b.c': true,\n    'a.e': true,\n    'c.c.c': true\n  }, \"multikey both paths - incl\");\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 1\n  }, {\n    'a.b': true,\n    'a.b1.c.d': true\n  }, \"shadowing one another - incl\");\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 1,\n    'foo': 1\n  }, {\n    'a.b': true,\n    'foo': true\n  }, \"shadowing one another - incl\");\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 1\n  }, {\n    'a.b.c': true\n  }, \"same paths - incl\");\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 1\n  }, {\n    'x.x': true,\n    'x.y': true,\n    'z': true\n  }, \"numbered keys in selector - incl\");\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () {\n      return true;\n    }\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\");\n  testSelProjectionComb({\n    $or: [{\n      'a.b.c': 42\n    }, {\n      $where: function () {\n        return true;\n      }\n    }]\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\"); // Test with exclusive projection\n\n  testSelProjectionComb({\n    a: 1,\n    b: 2\n  }, {\n    b: 0,\n    c: 0,\n    d: 0\n  }, {\n    c: false,\n    d: false\n  }, \"simplest excl\");\n  testSelProjectionComb({\n    $or: [{\n      a: 1234,\n      e: {\n        $lt: 5\n      }\n    }],\n    b: 2\n  }, {\n    b: 0,\n    c: 0,\n    d: 0\n  }, {\n    c: false,\n    d: false\n  }, \"simplest excl, branching\");\n  testSelProjectionComb({\n    'a.b': {\n      $lt: 3\n    },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 0,\n    'z': 0\n  }, {\n    d: false,\n    z: false\n  }, \"multikey paths in selector - excl\");\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{\n      k: -1\n    }, {\n      $or: [{\n        b: 15\n      }]\n    }]\n  }, {\n    'foo.bar': 0,\n    'foo.zzz': 0,\n    'b.asdf': 0\n  }, {}, \"multikey paths in fields - excl\");\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 0,\n    'a.b.d.g': 0,\n    'c.c.c': 0\n  }, {\n    'a.b.z': false,\n    'c.c.c': false\n  }, \"multikey both paths - excl\");\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 0\n  }, {}, \"shadowing one another - excl\");\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 0,\n    'foo': 0\n  }, {}, \"shadowing one another - excl\");\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 0\n  }, {}, \"same paths - excl\");\n  testSelProjectionComb({\n    'a.b': 123,\n    'a.c.d': 222,\n    'ddd': 123\n  }, {\n    'a.b': 0,\n    'a.c.e': 0,\n    'asdf': 0\n  }, {\n    'a.c.e': false,\n    'asdf': false\n  }, \"intercept the selector path - excl\");\n  testSelProjectionComb({\n    'a.b.c': 14\n  }, {\n    'a.b.d': 0\n  }, {\n    'a.b.d': false\n  }, \"different branches - excl\");\n  testSelProjectionComb({\n    'a.b.c.d': \"124\",\n    'foo.bar.baz.que': \"some value\"\n  }, {\n    'a.b.c.d.e': 0,\n    'foo.bar': 0\n  }, {}, \"excl on incl paths - excl\");\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 0,\n    'x.y': 0\n  }, {\n    'x.x': false\n  }, \"numbered keys in selector - excl\");\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () {\n      return true;\n    }\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n  testSelProjectionComb({\n    $or: [{\n      'a.b.c': 42\n    }, {\n      $where: function () {\n        return true;\n      }\n    }]\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n});\nTinytest.add(\"minimongo - sorter and projection combination\", function (test) {\n  function testSorterProjectionComb(sortSpec, proj, expected, desc) {\n    var sorter = new Minimongo.Sorter(sortSpec);\n    test.equal(sorter.combineIntoProjection(proj), expected, desc);\n  } // Test with inclusive projection\n\n\n  testSorterProjectionComb({\n    a: 1,\n    b: 1\n  }, {\n    b: 1,\n    c: 1,\n    d: 1\n  }, {\n    a: true,\n    b: true,\n    c: true,\n    d: true\n  }, \"simplest incl\");\n  testSorterProjectionComb({\n    a: 1,\n    b: -1\n  }, {\n    b: 1,\n    c: 1,\n    d: 1\n  }, {\n    a: true,\n    b: true,\n    c: true,\n    d: true\n  }, \"simplest incl\");\n  testSorterProjectionComb({\n    'a.c': 1\n  }, {\n    b: 1\n  }, {\n    'a.c': true,\n    b: true\n  }, \"dot path incl\");\n  testSorterProjectionComb({\n    'a.1.c': 1\n  }, {\n    b: 1\n  }, {\n    'a.c': true,\n    b: true\n  }, \"dot num path incl\");\n  testSorterProjectionComb({\n    'a.1.c': 1\n  }, {\n    b: 1,\n    a: 1\n  }, {\n    a: true,\n    b: true\n  }, \"dot num path incl overlap\");\n  testSorterProjectionComb({\n    'a.1.c': 1,\n    'a.2.b': -1\n  }, {\n    b: 1\n  }, {\n    'a.c': true,\n    'a.b': true,\n    b: true\n  }, \"dot num path incl\");\n  testSorterProjectionComb({\n    'a.1.c': 1,\n    'a.2.b': -1\n  }, {}, {}, \"dot num path with empty incl\"); // Test with exclusive projection\n\n  testSorterProjectionComb({\n    a: 1,\n    b: 1\n  }, {\n    b: 0,\n    c: 0,\n    d: 0\n  }, {\n    c: false,\n    d: false\n  }, \"simplest excl\");\n  testSorterProjectionComb({\n    a: 1,\n    b: -1\n  }, {\n    b: 0,\n    c: 0,\n    d: 0\n  }, {\n    c: false,\n    d: false\n  }, \"simplest excl\");\n  testSorterProjectionComb({\n    'a.c': 1\n  }, {\n    b: 0\n  }, {\n    b: false\n  }, \"dot path excl\");\n  testSorterProjectionComb({\n    'a.1.c': 1\n  }, {\n    b: 0\n  }, {\n    b: false\n  }, \"dot num path excl\");\n  testSorterProjectionComb({\n    'a.1.c': 1\n  }, {\n    b: 0,\n    a: 0\n  }, {\n    b: false\n  }, \"dot num path excl overlap\");\n  testSorterProjectionComb({\n    'a.1.c': 1,\n    'a.2.b': -1\n  }, {\n    b: 0\n  }, {\n    b: false\n  }, \"dot num path excl\");\n});\n\n(function () {\n  // TODO: Tests for \"can selector become true by modifier\" are incomplete,\n  // absent or test the functionality of \"not ideal\" implementation (test checks\n  // that certain case always returns true as implementation is incomplete)\n  // - tests with $and/$or/$nor/$not branches (are absent)\n  // - more tests with arrays fields and numeric keys (incomplete and test \"not\n  // ideal\" implementation)\n  // - tests when numeric keys actually mean numeric keys, not array indexes\n  // (are absent)\n  // - tests with $-operators in the selector (are incomplete and test \"not\n  // ideal\" implementation)\n  //  * gives up on $-operators with non-scalar values ({$ne: {x: 1}})\n  //  * analyses $in\n  //  * analyses $nin/$ne\n  //  * analyses $gt, $gte, $lt, $lte\n  //  * gives up on a combination of $gt/$gte/$lt/$lte and $ne/$nin\n  //  * doesn't support $eq properly\n  var test = null; // set this global in the beginning of every test\n  // T - should return true\n  // F - should return false\n\n  var oneTest = function (sel, mod, expected, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.canBecomeTrueByModifier(mod), expected, desc);\n  };\n\n  function T(sel, mod, desc) {\n    oneTest(sel, mod, true, desc);\n  }\n\n  function F(sel, mod, desc) {\n    oneTest(sel, mod, false, desc);\n  }\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (structured tests)\", function (t) {\n    test = t;\n    var selector = {\n      'a.b.c': 2,\n      'foo.bar': {\n        z: {\n          y: 1\n        }\n      },\n      'foo.baz': [{\n        ans: 42\n      }, \"string\", false, undefined],\n      'empty.field': null\n    };\n    T(selector, {\n      $set: {\n        'a.b.c': 2\n      }\n    });\n    F(selector, {\n      $unset: {\n        'a': 1\n      }\n    });\n    F(selector, {\n      $unset: {\n        'a.b': 1\n      }\n    });\n    F(selector, {\n      $unset: {\n        'a.b.c': 1\n      }\n    });\n    T(selector, {\n      $set: {\n        'a.b': {\n          c: 2\n        }\n      }\n    });\n    F(selector, {\n      $set: {\n        'a.b': {}\n      }\n    });\n    T(selector, {\n      $set: {\n        'a.b': {\n          c: 2,\n          x: 5\n        }\n      }\n    });\n    F(selector, {\n      $set: {\n        'a.b.c.k': 3\n      }\n    });\n    F(selector, {\n      $set: {\n        'a.b.c.k': {}\n      }\n    });\n    F(selector, {\n      $unset: {\n        'foo': 1\n      }\n    });\n    F(selector, {\n      $unset: {\n        'foo.bar': 1\n      }\n    });\n    F(selector, {\n      $unset: {\n        'foo.bar.z': 1\n      }\n    });\n    F(selector, {\n      $unset: {\n        'foo.bar.z.y': 1\n      }\n    });\n    F(selector, {\n      $set: {\n        'foo.bar.x': 1\n      }\n    });\n    F(selector, {\n      $set: {\n        'foo.bar': {}\n      }\n    });\n    F(selector, {\n      $set: {\n        'foo.bar': 3\n      }\n    });\n    T(selector, {\n      $set: {\n        'foo.bar': {\n          z: {\n            y: 1\n          }\n        }\n      }\n    });\n    T(selector, {\n      $set: {\n        'foo.bar.z': {\n          y: 1\n        }\n      }\n    });\n    T(selector, {\n      $set: {\n        'foo.bar.z.y': 1\n      }\n    });\n    F(selector, {\n      $set: {\n        'empty.field': {}\n      }\n    });\n    T(selector, {\n      $set: {\n        'empty': {}\n      }\n    });\n    T(selector, {\n      $set: {\n        'empty.field': null\n      }\n    });\n    T(selector, {\n      $set: {\n        'empty.field': undefined\n      }\n    });\n    F(selector, {\n      $set: {\n        'empty.field.a': 3\n      }\n    });\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (adhoc tests)\", function (t) {\n    test = t;\n    T({\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"simple set scalar\");\n    T({\n      x: \"a\"\n    }, {\n      $set: {\n        x: \"a\"\n      }\n    }, \"simple set scalar\");\n    T({\n      x: false\n    }, {\n      $set: {\n        x: false\n      }\n    }, \"simple set scalar\");\n    F({\n      x: true\n    }, {\n      $set: {\n        x: false\n      }\n    }, \"simple set scalar\");\n    F({\n      x: 2\n    }, {\n      $set: {\n        x: 3\n      }\n    }, \"simple set scalar\");\n    F({\n      'foo.bar.baz': 1,\n      x: 1\n    }, {\n      $unset: {\n        'foo.bar.baz': 1\n      },\n      $set: {\n        x: 1\n      }\n    }, \"simple unset of the interesting path\");\n    F({\n      'foo.bar.baz': 1,\n      x: 1\n    }, {\n      $unset: {\n        'foo.bar': 1\n      },\n      $set: {\n        x: 1\n      }\n    }, \"simple unset of the interesting path prefix\");\n    F({\n      'foo.bar.baz': 1,\n      x: 1\n    }, {\n      $unset: {\n        'foo': 1\n      },\n      $set: {\n        x: 1\n      }\n    }, \"simple unset of the interesting path prefix\");\n    F({\n      'foo.bar.baz': 1\n    }, {\n      $unset: {\n        'foo.baz': 1\n      }\n    }, \"simple unset of the interesting path prefix\");\n    F({\n      'foo.bar.baz': 1\n    }, {\n      $unset: {\n        'foo.bar.bar': 1\n      }\n    }, \"simple unset of the interesting path prefix\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - regexps\", function (t) {\n    test = t; // Regexp\n\n    T({\n      'foo.bar': /^[0-9]+$/i\n    }, {\n      $set: {\n        'foo.bar': '01233'\n      }\n    }, \"set of regexp\"); // XXX this test should be False, should be fixed within improved implementation\n\n    T({\n      'foo.bar': /^[0-9]+$/i,\n      x: 1\n    }, {\n      $set: {\n        'foo.bar': '0a1233',\n        x: 1\n      }\n    }, \"set of regexp\"); // XXX this test should be False, should be fixed within improved implementation\n\n    T({\n      'foo.bar': /^[0-9]+$/i,\n      x: 1\n    }, {\n      $unset: {\n        'foo.bar': 1\n      },\n      $set: {\n        x: 1\n      }\n    }, \"unset of regexp\");\n    T({\n      'foo.bar': /^[0-9]+$/i,\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"don't touch regexp\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - undefined/null\", function (t) {\n    test = t; // Nulls / Undefined\n\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo.bar': null\n      }\n    }, \"set of null looking for null\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo.bar': undefined\n      }\n    }, \"set of undefined looking for null\");\n    T({\n      'foo.bar': undefined\n    }, {\n      $set: {\n        'foo.bar': null\n      }\n    }, \"set of null looking for undefined\");\n    T({\n      'foo.bar': undefined\n    }, {\n      $set: {\n        'foo.bar': undefined\n      }\n    }, \"set of undefined looking for undefined\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo': null\n      }\n    }, \"set of null of parent path looking for null\");\n    F({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo.bar.baz': null\n      }\n    }, \"set of null of different path looking for null\");\n    T({\n      'foo.bar': null\n    }, {\n      $unset: {\n        'foo': 1\n      }\n    }, \"unset the parent\");\n    T({\n      'foo.bar': null\n    }, {\n      $unset: {\n        'foo.bar': 1\n      }\n    }, \"unset tracked path\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo': 3\n      }\n    }, \"set the parent\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo': {\n          baz: 1\n        }\n      }\n    }, \"set the parent\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals with arrays\", function (t) {\n    test = t; // These tests are incomplete and in theory they all should return true as we\n    // don't support any case with numeric fields yet.\n\n    T({\n      'a.1.b': 1,\n      x: 1\n    }, {\n      $unset: {\n        'a.1.b': 1\n      },\n      $set: {\n        x: 1\n      }\n    }, \"unset of array element's field with exactly the same index as selector\");\n    F({\n      'a.2.b': 1\n    }, {\n      $unset: {\n        'a.1.b': 1\n      }\n    }, \"unset of array element's field with different index as selector\"); // This is false, because if you are looking for array but in reality it is an\n    // object, it just can't get to true.\n\n    F({\n      'a.2.b': 1\n    }, {\n      $unset: {\n        'a.b': 1\n      }\n    }, \"unset of field while selector is looking for index\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo.1.bar': null\n      }\n    }, \"set array's element's field to null looking for null\");\n    T({\n      'foo.bar': null\n    }, {\n      $set: {\n        'foo.0.bar': 1,\n        'foo.1.bar': null\n      }\n    }, \"set array's element's field to null looking for null\"); // This is false, because there may remain other array elements that match\n    // but we modified this test as we don't support this case yet\n\n    T({\n      'a.b': 1\n    }, {\n      $unset: {\n        'a.1.b': 1\n      }\n    }, \"unset of array element's field\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - set an object literal whose fields are selected\", function (t) {\n    test = t;\n    T({\n      'a.b.c': 1\n    }, {\n      $set: {\n        'a.b': {\n          c: 1\n        }\n      }\n    }, \"a simple scalar selector and simple set\");\n    F({\n      'a.b.c': 1\n    }, {\n      $set: {\n        'a.b': {\n          c: 2\n        }\n      }\n    }, \"a simple scalar selector and simple set to false\");\n    F({\n      'a.b.c': 1\n    }, {\n      $set: {\n        'a.b': {\n          d: 1\n        }\n      }\n    }, \"a simple scalar selector and simple set a wrong literal\");\n    F({\n      'a.b.c': 1\n    }, {\n      $set: {\n        'a.b': 222\n      }\n    }, \"a simple scalar selector and simple set a wrong type\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - $-scalar selectors and simple tests\", function (t) {\n    test = t;\n    T({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b': {\n          c: 4\n        }\n      }\n    }, \"nested $lt\");\n    F({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b': {\n          c: 5\n        }\n      }\n    }, \"nested $lt\");\n    F({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b': {\n          c: 6\n        }\n      }\n    }, \"nested $lt\");\n    F({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b.d': 7\n      }\n    }, \"nested $lt, the change doesn't matter\");\n    F({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b': {\n          d: 7\n        }\n      }\n    }, \"nested $lt, the key disappears\");\n    T({\n      'a.b.c': {\n        $lt: 5\n      }\n    }, {\n      $set: {\n        'a.b': {\n          d: 7,\n          c: -1\n        }\n      }\n    }, \"nested $lt\");\n    F({\n      a: {\n        $lt: 10,\n        $gt: 3\n      }\n    }, {\n      $unset: {\n        a: 1\n      }\n    }, \"unset $lt\");\n    T({\n      a: {\n        $lt: 10,\n        $gt: 3\n      }\n    }, {\n      $set: {\n        a: 4\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lt: 10,\n        $gt: 3\n      }\n    }, {\n      $set: {\n        a: 3\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lt: 10,\n        $gt: 3\n      }\n    }, {\n      $set: {\n        a: 10\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $gt: 10,\n        $lt: 3\n      }\n    }, {\n      $set: {\n        a: 9\n      }\n    }, \"impossible statement\");\n    T({\n      a: {\n        $lte: 10,\n        $gte: 3\n      }\n    }, {\n      $set: {\n        a: 3\n      }\n    }, \"set between x and y\");\n    T({\n      a: {\n        $lte: 10,\n        $gte: 3\n      }\n    }, {\n      $set: {\n        a: 10\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 3\n      }\n    }, {\n      $set: {\n        a: -10\n      }\n    }, \"set between x and y\");\n    T({\n      a: {\n        $lte: 10,\n        $gte: 3,\n        $gt: 3,\n        $lt: 10\n      }\n    }, {\n      $set: {\n        a: 4\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 3,\n        $gt: 3,\n        $lt: 10\n      }\n    }, {\n      $set: {\n        a: 3\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 3,\n        $gt: 3,\n        $lt: 10\n      }\n    }, {\n      $set: {\n        a: 10\n      }\n    }, \"set between x and y\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 3,\n        $gt: 3,\n        $lt: 10\n      }\n    }, {\n      $set: {\n        a: Infinity\n      }\n    }, \"set between x and y\");\n    T({\n      a: {\n        $lte: 10,\n        $gte: 3,\n        $gt: 3,\n        $lt: 10\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"set between x and y - dummy\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 13,\n        $gt: 3,\n        $lt: 9\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"set between x and y - dummy - impossible\");\n    F({\n      a: {\n        $lte: 10\n      }\n    }, {\n      $set: {\n        a: Infinity\n      }\n    }, \"Infinity <= 10?\");\n    T({\n      a: {\n        $lte: 10\n      }\n    }, {\n      $set: {\n        a: -Infinity\n      }\n    }, \"-Infinity <= 10?\"); // XXX is this sufficient?\n\n    T({\n      a: {\n        $gt: 9.99999999999999,\n        $lt: 10\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"very close $gt and $lt\"); // XXX this test should be F, but since it is so hard to be precise in\n    // floating point math, the current implementation falls back to T\n\n    T({\n      a: {\n        $gt: 9.999999999999999,\n        $lt: 10\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"very close $gt and $lt\");\n    T({\n      a: {\n        $eq: 5\n      }\n    }, {\n      $set: {\n        a: 5\n      }\n    }, \"set of $eq\");\n    T({\n      a: {\n        $eq: 5\n      },\n      b: {\n        $eq: 7\n      }\n    }, {\n      $set: {\n        a: 5\n      }\n    }, \"set of $eq with other $eq\");\n    F({\n      a: {\n        $eq: 5\n      }\n    }, {\n      $set: {\n        a: 4\n      }\n    }, \"set below of $eq\");\n    F({\n      a: {\n        $eq: 5\n      }\n    }, {\n      $set: {\n        a: 6\n      }\n    }, \"set above of $eq\");\n    T({\n      a: {\n        $ne: 5\n      }\n    }, {\n      $unset: {\n        a: 1\n      }\n    }, \"unset of $ne\");\n    T({\n      a: {\n        $ne: 5\n      }\n    }, {\n      $set: {\n        a: 1\n      }\n    }, \"set of $ne\");\n    T({\n      a: {\n        $ne: \"some string\"\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\");\n    T({\n      a: {\n        $ne: true\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\");\n    T({\n      a: {\n        $ne: false\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\");\n    T({\n      a: {\n        $ne: null\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\");\n    T({\n      a: {\n        $ne: Infinity\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\");\n    T({\n      a: {\n        $ne: 5\n      }\n    }, {\n      $set: {\n        a: -10\n      }\n    }, \"set of $ne\");\n    T({\n      a: {\n        $in: [1, 3, 5, 7]\n      }\n    }, {\n      $set: {\n        a: 5\n      }\n    }, \"$in checks\");\n    F({\n      a: {\n        $in: [1, 3, 5, 7]\n      }\n    }, {\n      $set: {\n        a: -5\n      }\n    }, \"$in checks\");\n    T({\n      a: {\n        $in: [1, 3, 5, 7],\n        $gt: 6\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$in combination with $gt\");\n    F({\n      a: {\n        $lte: 10,\n        $gte: 3\n      }\n    }, {\n      $set: {\n        'a.b': -10\n      }\n    }, \"sel between x and y, set its subfield\");\n    F({\n      b: {\n        $in: [1, 3, 5, 7]\n      }\n    }, {\n      $set: {\n        'b.c': 2\n      }\n    }, \"sel $in, set subfield\");\n    T({\n      b: {\n        $in: [1, 3, 5, 7]\n      }\n    }, {\n      $set: {\n        'bd.c': 2,\n        b: 3\n      }\n    }, \"sel $in, set similar subfield\");\n    F({\n      'b.c': {\n        $in: [1, 3, 5, 7]\n      }\n    }, {\n      $set: {\n        b: 2\n      }\n    }, \"sel subfield of set scalar\"); // If modifier tries to set a sub-field of a path expected to be a scalar.\n\n    F({\n      'a.b': {\n        $gt: 5,\n        $lt: 7\n      },\n      x: 1\n    }, {\n      $set: {\n        'a.b.c': 3,\n        x: 1\n      }\n    }, \"set sub-field of $gt,$lt operator (scalar expected)\");\n    F({\n      'a.b': {\n        $gt: 5,\n        $lt: 7\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      },\n      $unset: {\n        'a.b.c': 1\n      }\n    }, \"unset sub-field of $gt,$lt operator (scalar expected)\");\n  });\n  Tinytest.add(\"minimongo - can selector become true by modifier - $-nonscalar selectors and simple tests\", function (t) {\n    test = t;\n    T({\n      a: {\n        $eq: {\n          x: 5\n        }\n      }\n    }, {\n      $set: {\n        'a.x': 5\n      }\n    }, \"set of $eq\"); // XXX this test should be F, but it is not implemented yet\n\n    T({\n      a: {\n        $eq: {\n          x: 5\n        }\n      }\n    }, {\n      $set: {\n        'a.x': 4\n      }\n    }, \"set of $eq\"); // XXX this test should be F, but it is not implemented yet\n\n    T({\n      a: {\n        $eq: {\n          x: 5\n        }\n      }\n    }, {\n      $set: {\n        'a.y': 4\n      }\n    }, \"set of $eq\");\n    T({\n      a: {\n        $ne: {\n          x: 5\n        }\n      }\n    }, {\n      $set: {\n        'a.x': 3\n      }\n    }, \"set of $ne\"); // XXX this test should be F, but it is not implemented yet\n\n    T({\n      a: {\n        $ne: {\n          x: 5\n        }\n      }\n    }, {\n      $set: {\n        'a.x': 5\n      }\n    }, \"set of $ne\");\n    T({\n      a: {\n        $in: [{\n          b: 1\n        }, {\n          b: 3\n        }]\n      }\n    }, {\n      $set: {\n        a: {\n          b: 3\n        }\n      }\n    }, \"$in checks\"); // XXX this test should be F, but it is not implemented yet\n\n    T({\n      a: {\n        $in: [{\n          b: 1\n        }, {\n          b: 3\n        }]\n      }\n    }, {\n      $set: {\n        a: {\n          v: 3\n        }\n      }\n    }, \"$in checks\");\n    T({\n      a: {\n        $ne: {\n          a: 2\n        }\n      },\n      x: 1\n    }, {\n      $set: {\n        x: 1\n      }\n    }, \"$ne dummy\"); // XXX this test should be F, but it is not implemented yet\n\n    T({\n      a: {\n        $ne: {\n          a: 2\n        }\n      }\n    }, {\n      $set: {\n        a: {\n          a: 2\n        }\n      }\n    }, \"$ne object\");\n  });\n})();","map":{"version":3,"sources":["/packages/minimongo/minimongo_server_tests.js"],"names":["Tinytest","add","test","testSelectorPaths","sel","paths","desc","matcher","Minimongo","Matcher","equal","_getPaths","foo","bar","baz","a","$lt","b","$not","$regex","$or","$and","$ne","$gte","literal","but","x","$elemMatch","y","testSelectorAffectedByModifier","mod","yes","affectedByModifier","affected","notAffected","$set","$unset","testSelProjectionComb","proj","expected","combineIntoProjection","c","d","e","k","$where","z","testSorterProjectionComb","sortSpec","sorter","Sorter","oneTest","canBecomeTrueByModifier","T","F","t","selector","ans","undefined","$gt","$lte","Infinity","$eq","$in","v"],"mappings":"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","file":"/packages/minimongo/minimongo_server_tests.js.map","sourcesContent":["Tinytest.add(\"minimongo - modifier affects selector\", function (test) {\n  function testSelectorPaths (sel, paths, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher._getPaths(), paths, desc);\n  }\n\n  testSelectorPaths({\n    foo: {\n      bar: 3,\n      baz: 42\n    }\n  }, ['foo'], \"literal\");\n\n  testSelectorPaths({\n    foo: 42,\n    bar: 33\n  }, ['foo', 'bar'], \"literal\");\n\n  testSelectorPaths({\n    foo: [ 'something' ],\n    bar: \"asdf\"\n  }, ['foo', 'bar'], \"literal\");\n\n  testSelectorPaths({\n    a: { $lt: 3 },\n    b: \"you know, literal\",\n    'path.is.complicated': { $not: { $regex: 'acme.*corp' } }\n  }, ['a', 'b', 'path.is.complicated'], \"literal + operators\");\n\n  testSelectorPaths({\n    $or: [{ 'a.b': 1 }, { 'a.b.c': { $lt: 22 } },\n     {$and: [{ 'x.d': { $ne: 5, $gte: 433 } }, { 'a.b': 234 }]}]\n  }, ['a.b', 'a.b.c', 'x.d'], 'group operators + duplicates');\n\n  // When top-level value is an object, it is treated as a literal,\n  // so when you query col.find({ a: { foo: 1, bar: 2 } })\n  // it doesn't mean you are looking for anything that has 'a.foo' to be 1 and\n  // 'a.bar' to be 2, instead you are looking for 'a' to be exatly that object\n  // with exatly that order of keys. { a: { foo: 1, bar: 2, baz: 3 } } wouldn't\n  // match it. That's why in this selector 'a' would be important key, not a.foo\n  // and a.bar.\n  testSelectorPaths({\n    a: {\n      foo: 1,\n      bar: 2\n    },\n    'b.c': {\n      literal: \"object\",\n      but: \"we still observe any changes in 'b.c'\"\n    }\n  }, ['a', 'b.c'], \"literal object\");\n\n  // Note that a and b do NOT end up in the path list, but x and y both do.\n  testSelectorPaths({\n    $or: [\n      {x: {$elemMatch: {a: 5}}},\n      {y: {$elemMatch: {b: 7}}}\n    ]\n  }, ['x', 'y'], \"$or and elemMatch\");\n\n  function testSelectorAffectedByModifier (sel, mod, yes, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.affectedByModifier(mod), yes, desc);\n  }\n\n  function affected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, true, desc);\n  }\n  function notAffected(sel, mod, desc) {\n    testSelectorAffectedByModifier(sel, mod, false, desc);\n  }\n\n  notAffected({ foo: 0 }, { $set: { bar: 1 } }, \"simplest\");\n  affected({ foo: 0 }, { $set: { foo: 1 } }, \"simplest\");\n  affected({ foo: 0 }, { $set: { 'foo.bar': 1 } }, \"simplest\");\n  notAffected({ 'foo.bar': 0 }, { $set: { 'foo.baz': 1 } }, \"simplest\");\n  affected({ 'foo.bar': 0 }, { $set: { 'foo.1': 1 } }, \"simplest\");\n  affected({ 'foo.bar': 0 }, { $set: { 'foo.2.bar': 1 } }, \"simplest\");\n\n  notAffected({ 'foo': 0 }, { $set: { 'foobaz': 1 } }, \"correct prefix check\");\n  notAffected({ 'foobar': 0 }, { $unset: { 'foo': 1 } }, \"correct prefix check\");\n  notAffected({ 'foo.bar': 0 }, { $unset: { 'foob': 1 } }, \"correct prefix check\");\n\n  notAffected({ 'foo.Infinity.x': 0 }, { $unset: { 'foo.x': 1 } }, \"we convert integer fields correctly\");\n  notAffected({ 'foo.1e3.x': 0 }, { $unset: { 'foo.x': 1 } }, \"we convert integer fields correctly\");\n\n  affected({ 'foo.3.bar': 0 }, { $set: { 'foo.3.bar': 1 } }, \"observe for an array element\");\n\n  notAffected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.3.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  notAffected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  affected({ 'foo.4.bar.baz': 0 }, { $unset: { 'foo.4.bar': 1 } }, \"delicate work with numeric fields in selector\");\n  affected({ 'foo.bar.baz': 0 }, { $unset: { 'foo.3.bar': 1 } }, \"delicate work with numeric fields in selector\");\n\n  affected({ 'foo.0.bar': 0 }, { $set: { 'foo.0.0.bar': 1 } }, \"delicate work with nested arrays and selectors by indecies\");\n\n  affected({foo: {$elemMatch: {bar: 5}}}, {$set: {'foo.4.bar': 5}}, \"$elemMatch\");\n});\n\nTinytest.add(\"minimongo - selector and projection combination\", function (test) {\n  function testSelProjectionComb (sel, proj, expected, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.combineIntoProjection(proj), expected, desc);\n  }\n\n  // Test with inclusive projection\n  testSelProjectionComb({ a: 1, b: 2 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true }, \"simplest incl\");\n  testSelProjectionComb({ $or: [{ a: 1234, e: {$lt: 5} }], b: 2 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true, e: true }, \"simplest incl, branching\");\n  testSelProjectionComb({\n    'a.b': { $lt: 3 },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 1,\n    'z': 1\n  }, {\n    'a.b': true,\n    'y': true,\n    'a.c': true,\n    'd': true,\n    'z': true\n  }, \"multikey paths in selector - incl\");\n\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{ k: -1 }, { $or: [{ b: 15 }] }]\n  }, {\n    'foo.bar': 1,\n    'foo.zzz': 1,\n    'b.asdf': 1\n  }, {\n    foo: true,\n    b: true,\n    k: true\n  }, \"multikey paths in fields - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 1,\n    'a.b.d.g': 1,\n    'c.c.c': 1\n  }, {\n    'a.b.c': true,\n    'a.b.d': true,\n    'a.b.z': true,\n    'b.c': true,\n    'a.e': true,\n    'c.c.c': true\n  }, \"multikey both paths - incl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 1\n  }, {\n    'a.b': true,\n    'a.b1.c.d': true\n  }, \"shadowing one another - incl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 1,\n    'foo': 1\n  }, {\n    'a.b': true,\n    'foo': true\n  }, \"shadowing one another - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 1\n  }, {\n    'a.b.c': true\n  }, \"same paths - incl\");\n\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 1\n  }, {\n    'x.x': true,\n    'x.y': true,\n    'z': true\n  }, \"numbered keys in selector - incl\");\n\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () { return true; }\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\");\n\n  testSelProjectionComb({\n    $or: [\n      {'a.b.c': 42},\n      {$where: function () { return true; } }\n    ]\n  }, {\n    'a.b': 1,\n    'z.z': 1\n  }, {}, \"$where in the selector - incl\");\n\n  // Test with exclusive projection\n  testSelProjectionComb({ a: 1, b: 2 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl\");\n  testSelProjectionComb({ $or: [{ a: 1234, e: {$lt: 5} }], b: 2 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl, branching\");\n  testSelProjectionComb({\n    'a.b': { $lt: 3 },\n    'y.0': -1,\n    'a.c': 15\n  }, {\n    'd': 0,\n    'z': 0\n  }, {\n    d: false,\n    z: false\n  }, \"multikey paths in selector - excl\");\n\n  testSelProjectionComb({\n    foo: 1234,\n    $and: [{ k: -1 }, { $or: [{ b: 15 }] }]\n  }, {\n    'foo.bar': 0,\n    'foo.zzz': 0,\n    'b.asdf': 0\n  }, {\n  }, \"multikey paths in fields - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 123,\n    'a.b.d': 321,\n    'b.c.0': 111,\n    'a.e': 12345\n  }, {\n    'a.b.z': 0,\n    'a.b.d.g': 0,\n    'c.c.c': 0\n  }, {\n    'a.b.z': false,\n    'c.c.c': false\n  }, \"multikey both paths - excl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': 123,\n    'a.b1.c.d': 421,\n    'a.b.c.e': 111\n  }, {\n    'a.b': 0\n  }, {\n  }, \"shadowing one another - excl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'foo.bar': false\n  }, {\n    'a.b.c.d': 0,\n    'foo': 0\n  }, {\n  }, \"shadowing one another - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 1\n  }, {\n    'a.b.c': 0\n  }, {\n  }, \"same paths - excl\");\n\n  testSelProjectionComb({\n    'a.b': 123,\n    'a.c.d': 222,\n    'ddd': 123\n  }, {\n    'a.b': 0,\n    'a.c.e': 0,\n    'asdf': 0\n  }, {\n    'a.c.e': false,\n    'asdf': false\n  }, \"intercept the selector path - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 14\n  }, {\n    'a.b.d': 0\n  }, {\n    'a.b.d': false\n  }, \"different branches - excl\");\n\n  testSelProjectionComb({\n    'a.b.c.d': \"124\",\n    'foo.bar.baz.que': \"some value\"\n  }, {\n    'a.b.c.d.e': 0,\n    'foo.bar': 0\n  }, {\n  }, \"excl on incl paths - excl\");\n\n  testSelProjectionComb({\n    'x.4.y': 42,\n    'z.0.1': 33\n  }, {\n    'x.x': 0,\n    'x.y': 0\n  }, {\n    'x.x': false,\n  }, \"numbered keys in selector - excl\");\n\n  testSelProjectionComb({\n    'a.b.c': 42,\n    $where: function () { return true; }\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n\n  testSelProjectionComb({\n    $or: [\n      {'a.b.c': 42},\n      {$where: function () { return true; } }\n    ]\n  }, {\n    'a.b': 0,\n    'z.z': 0\n  }, {}, \"$where in the selector - excl\");\n\n});\n\nTinytest.add(\"minimongo - sorter and projection combination\", function (test) {\n  function testSorterProjectionComb (sortSpec, proj, expected, desc) {\n    var sorter = new Minimongo.Sorter(sortSpec);\n    test.equal(sorter.combineIntoProjection(proj), expected, desc);\n  }\n\n  // Test with inclusive projection\n  testSorterProjectionComb({ a: 1, b: 1 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true }, \"simplest incl\");\n  testSorterProjectionComb({ a: 1, b: -1 }, { b: 1, c: 1, d: 1 }, { a: true, b: true, c: true, d: true }, \"simplest incl\");\n  testSorterProjectionComb({ 'a.c': 1 }, { b: 1 }, { 'a.c': true, b: true }, \"dot path incl\");\n  testSorterProjectionComb({ 'a.1.c': 1 }, { b: 1 }, { 'a.c': true, b: true }, \"dot num path incl\");\n  testSorterProjectionComb({ 'a.1.c': 1 }, { b: 1, a: 1 }, { a: true, b: true }, \"dot num path incl overlap\");\n  testSorterProjectionComb({ 'a.1.c': 1, 'a.2.b': -1 }, { b: 1 }, { 'a.c': true, 'a.b': true, b: true }, \"dot num path incl\");\n  testSorterProjectionComb({ 'a.1.c': 1, 'a.2.b': -1 }, {}, {}, \"dot num path with empty incl\");\n\n  // Test with exclusive projection\n  testSorterProjectionComb({ a: 1, b: 1 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl\");\n  testSorterProjectionComb({ a: 1, b: -1 }, { b: 0, c: 0, d: 0 }, { c: false, d: false }, \"simplest excl\");\n  testSorterProjectionComb({ 'a.c': 1 }, { b: 0 }, { b: false }, \"dot path excl\");\n  testSorterProjectionComb({ 'a.1.c': 1 }, { b: 0 }, { b: false }, \"dot num path excl\");\n  testSorterProjectionComb({ 'a.1.c': 1 }, { b: 0, a: 0 }, { b: false }, \"dot num path excl overlap\");\n  testSorterProjectionComb({ 'a.1.c': 1, 'a.2.b': -1 }, { b: 0 }, { b: false }, \"dot num path excl\");\n});\n\n\n(function () {\n  // TODO: Tests for \"can selector become true by modifier\" are incomplete,\n  // absent or test the functionality of \"not ideal\" implementation (test checks\n  // that certain case always returns true as implementation is incomplete)\n  // - tests with $and/$or/$nor/$not branches (are absent)\n  // - more tests with arrays fields and numeric keys (incomplete and test \"not\n  // ideal\" implementation)\n  // - tests when numeric keys actually mean numeric keys, not array indexes\n  // (are absent)\n  // - tests with $-operators in the selector (are incomplete and test \"not\n  // ideal\" implementation)\n  //  * gives up on $-operators with non-scalar values ({$ne: {x: 1}})\n  //  * analyses $in\n  //  * analyses $nin/$ne\n  //  * analyses $gt, $gte, $lt, $lte\n  //  * gives up on a combination of $gt/$gte/$lt/$lte and $ne/$nin\n  //  * doesn't support $eq properly\n\n  var test = null; // set this global in the beginning of every test\n  // T - should return true\n  // F - should return false\n  var oneTest = function (sel, mod, expected, desc) {\n    var matcher = new Minimongo.Matcher(sel);\n    test.equal(matcher.canBecomeTrueByModifier(mod), expected, desc);\n  };\n  function T (sel, mod, desc) {\n    oneTest(sel, mod, true, desc);\n  }\n  function F (sel, mod, desc) {\n    oneTest(sel, mod, false, desc);\n  }\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (structured tests)\", function (t) {\n    test = t;\n\n    var selector = {\n      'a.b.c': 2,\n      'foo.bar': {\n        z: { y: 1 }\n      },\n      'foo.baz': [ {ans: 42}, \"string\", false, undefined ],\n      'empty.field': null\n    };\n\n    T(selector, {$set:{ 'a.b.c': 2 }});\n    F(selector, {$unset:{ 'a': 1 }});\n    F(selector, {$unset:{ 'a.b': 1 }});\n    F(selector, {$unset:{ 'a.b.c': 1 }});\n    T(selector, {$set:{ 'a.b': { c: 2 } }});\n    F(selector, {$set:{ 'a.b': {} }});\n    T(selector, {$set:{ 'a.b': { c: 2, x: 5 } }});\n    F(selector, {$set:{ 'a.b.c.k': 3 }});\n    F(selector, {$set:{ 'a.b.c.k': {} }});\n\n    F(selector, {$unset:{ 'foo': 1 }});\n    F(selector, {$unset:{ 'foo.bar': 1 }});\n    F(selector, {$unset:{ 'foo.bar.z': 1 }});\n    F(selector, {$unset:{ 'foo.bar.z.y': 1 }});\n    F(selector, {$set:{ 'foo.bar.x': 1 }});\n    F(selector, {$set:{ 'foo.bar': {} }});\n    F(selector, {$set:{ 'foo.bar': 3 }});\n    T(selector, {$set:{ 'foo.bar': { z: { y: 1 } } }});\n    T(selector, {$set:{ 'foo.bar.z': { y: 1 } }});\n    T(selector, {$set:{ 'foo.bar.z.y': 1 }});\n\n    F(selector, {$set:{ 'empty.field': {} }});\n    T(selector, {$set:{ 'empty': {} }});\n    T(selector, {$set:{ 'empty.field': null }});\n    T(selector, {$set:{ 'empty.field': undefined }});\n    F(selector, {$set:{ 'empty.field.a': 3 }});\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals (adhoc tests)\", function (t) {\n    test = t;\n    T({x:1}, {$set:{x:1}}, \"simple set scalar\");\n    T({x:\"a\"}, {$set:{x:\"a\"}}, \"simple set scalar\");\n    T({x:false}, {$set:{x:false}}, \"simple set scalar\");\n    F({x:true}, {$set:{x:false}}, \"simple set scalar\");\n    F({x:2}, {$set:{x:3}}, \"simple set scalar\");\n\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo.bar.baz': 1}, $set:{x:1}}, \"simple unset of the interesting path\");\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo.bar': 1}, $set:{x:1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1, x:1}, {$unset:{'foo': 1}, $set:{x:1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1}, {$unset:{'foo.baz': 1}}, \"simple unset of the interesting path prefix\");\n    F({'foo.bar.baz': 1}, {$unset:{'foo.bar.bar': 1}}, \"simple unset of the interesting path prefix\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - regexps\", function (t) {\n    test = t;\n\n    // Regexp\n    T({ 'foo.bar': /^[0-9]+$/i }, { $set: {'foo.bar': '01233'} }, \"set of regexp\");\n    // XXX this test should be False, should be fixed within improved implementation\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $set: {'foo.bar': '0a1233', x: 1} }, \"set of regexp\");\n    // XXX this test should be False, should be fixed within improved implementation\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $unset: {'foo.bar': 1}, $set: { x: 1 } }, \"unset of regexp\");\n    T({ 'foo.bar': /^[0-9]+$/i, x: 1 }, { $set: { x: 1 } }, \"don't touch regexp\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - undefined/null\", function (t) {\n    test = t;\n    // Nulls / Undefined\n    T({ 'foo.bar': null }, {$set:{'foo.bar': null}}, \"set of null looking for null\");\n    T({ 'foo.bar': null }, {$set:{'foo.bar': undefined}}, \"set of undefined looking for null\");\n    T({ 'foo.bar': undefined }, {$set:{'foo.bar': null}}, \"set of null looking for undefined\");\n    T({ 'foo.bar': undefined }, {$set:{'foo.bar': undefined}}, \"set of undefined looking for undefined\");\n    T({ 'foo.bar': null }, {$set:{'foo': null}}, \"set of null of parent path looking for null\");\n    F({ 'foo.bar': null }, {$set:{'foo.bar.baz': null}}, \"set of null of different path looking for null\");\n    T({ 'foo.bar': null }, { $unset: { 'foo': 1 } }, \"unset the parent\");\n    T({ 'foo.bar': null }, { $unset: { 'foo.bar': 1 } }, \"unset tracked path\");\n    T({ 'foo.bar': null }, { $set: { 'foo': 3 } }, \"set the parent\");\n    T({ 'foo.bar': null }, { $set: { 'foo': {baz:1} } }, \"set the parent\");\n\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - literals with arrays\", function (t) {\n    test = t;\n    // These tests are incomplete and in theory they all should return true as we\n    // don't support any case with numeric fields yet.\n    T({'a.1.b': 1, x:1}, {$unset:{'a.1.b': 1}, $set:{x:1}}, \"unset of array element's field with exactly the same index as selector\");\n    F({'a.2.b': 1}, {$unset:{'a.1.b': 1}}, \"unset of array element's field with different index as selector\");\n    // This is false, because if you are looking for array but in reality it is an\n    // object, it just can't get to true.\n    F({'a.2.b': 1}, {$unset:{'a.b': 1}}, \"unset of field while selector is looking for index\");\n    T({ 'foo.bar': null }, {$set:{'foo.1.bar': null}}, \"set array's element's field to null looking for null\");\n    T({ 'foo.bar': null }, {$set:{'foo.0.bar': 1, 'foo.1.bar': null}}, \"set array's element's field to null looking for null\");\n    // This is false, because there may remain other array elements that match\n    // but we modified this test as we don't support this case yet\n    T({'a.b': 1}, {$unset:{'a.1.b': 1}}, \"unset of array element's field\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - set an object literal whose fields are selected\", function (t) {\n    test = t;\n    T({ 'a.b.c': 1 }, { $set: { 'a.b': { c: 1 } } }, \"a simple scalar selector and simple set\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': { c: 2 } } }, \"a simple scalar selector and simple set to false\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': { d: 1 } } }, \"a simple scalar selector and simple set a wrong literal\");\n    F({ 'a.b.c': 1 }, { $set: { 'a.b': 222 } }, \"a simple scalar selector and simple set a wrong type\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - $-scalar selectors and simple tests\", function (t) {\n    test = t;\n    T({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b': { c: 4 } } }, \"nested $lt\");\n    F({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b': { c: 5 } } }, \"nested $lt\");\n    F({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b': { c: 6 } } }, \"nested $lt\");\n    F({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b.d': 7 } }, \"nested $lt, the change doesn't matter\");\n    F({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b': { d: 7 } } }, \"nested $lt, the key disappears\");\n    T({ 'a.b.c': { $lt: 5 } }, { $set: { 'a.b': { d: 7, c: -1 } } }, \"nested $lt\");\n    F({ a: { $lt: 10, $gt: 3 } }, { $unset: { a: 1 } }, \"unset $lt\");\n    T({ a: { $lt: 10, $gt: 3 } }, { $set: { a: 4 } }, \"set between x and y\");\n    F({ a: { $lt: 10, $gt: 3 } }, { $set: { a: 3 } }, \"set between x and y\");\n    F({ a: { $lt: 10, $gt: 3 } }, { $set: { a: 10 } }, \"set between x and y\");\n    F({ a: { $gt: 10, $lt: 3 } }, { $set: { a: 9 } }, \"impossible statement\");\n    T({ a: { $lte: 10, $gte: 3 } }, { $set: { a: 3 } }, \"set between x and y\");\n    T({ a: { $lte: 10, $gte: 3 } }, { $set: { a: 10 } }, \"set between x and y\");\n    F({ a: { $lte: 10, $gte: 3 } }, { $set: { a: -10 } }, \"set between x and y\");\n    T({ a: { $lte: 10, $gte: 3, $gt: 3, $lt: 10 } }, { $set: { a: 4 } }, \"set between x and y\");\n    F({ a: { $lte: 10, $gte: 3, $gt: 3, $lt: 10 } }, { $set: { a: 3 } }, \"set between x and y\");\n    F({ a: { $lte: 10, $gte: 3, $gt: 3, $lt: 10 } }, { $set: { a: 10 } }, \"set between x and y\");\n    F({ a: { $lte: 10, $gte: 3, $gt: 3, $lt: 10 } }, { $set: { a: Infinity } }, \"set between x and y\");\n    T({ a: { $lte: 10, $gte: 3, $gt: 3, $lt: 10 }, x: 1 }, { $set: { x: 1 } }, \"set between x and y - dummy\");\n    F({ a: { $lte: 10, $gte: 13, $gt: 3, $lt: 9 }, x: 1 }, { $set: { x: 1 } }, \"set between x and y - dummy - impossible\");\n    F({ a: { $lte: 10 } }, { $set: { a: Infinity } }, \"Infinity <= 10?\");\n    T({ a: { $lte: 10 } }, { $set: { a: -Infinity } }, \"-Infinity <= 10?\");\n    // XXX is this sufficient?\n    T({ a: { $gt: 9.99999999999999, $lt: 10 }, x: 1 }, { $set: { x: 1 } }, \"very close $gt and $lt\");\n    // XXX this test should be F, but since it is so hard to be precise in\n    // floating point math, the current implementation falls back to T\n    T({ a: { $gt: 9.999999999999999, $lt: 10 }, x: 1 }, { $set: { x: 1 } }, \"very close $gt and $lt\");\n    T({ a: { $eq: 5 } }, { $set: { a: 5 } }, \"set of $eq\");\n    T({ a: { $eq: 5 }, b: { $eq: 7 } }, { $set: { a: 5 } }, \"set of $eq with other $eq\");\n    F({ a: { $eq: 5 } }, { $set: { a: 4 } }, \"set below of $eq\");\n    F({ a: { $eq: 5 } }, { $set: { a: 6 } }, \"set above of $eq\");\n    T({ a: { $ne: 5 } }, { $unset: { a: 1 } }, \"unset of $ne\");\n    T({ a: { $ne: 5 } }, { $set: { a: 1 } }, \"set of $ne\");\n    T({ a: { $ne: \"some string\" }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    T({ a: { $ne: true }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    T({ a: { $ne: false }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    T({ a: { $ne: null }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    T({ a: { $ne: Infinity }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    T({ a: { $ne: 5 } }, { $set: { a: -10 } }, \"set of $ne\");\n    T({ a: { $in: [1, 3, 5, 7] } }, { $set: { a: 5 } }, \"$in checks\");\n    F({ a: { $in: [1, 3, 5, 7] } }, { $set: { a: -5 } }, \"$in checks\");\n    T({ a: { $in: [1, 3, 5, 7], $gt: 6 }, x: 1 }, { $set: { x: 1 } }, \"$in combination with $gt\");\n    F({ a: { $lte: 10, $gte: 3 } }, { $set: { 'a.b': -10 } }, \"sel between x and y, set its subfield\");\n    F({ b: { $in: [1, 3, 5, 7] } }, { $set: { 'b.c': 2 } }, \"sel $in, set subfield\");\n    T({ b: { $in: [1, 3, 5, 7] } }, { $set: { 'bd.c': 2, b: 3 } }, \"sel $in, set similar subfield\");\n    F({ 'b.c': { $in: [1, 3, 5, 7] } }, { $set: { b: 2 } }, \"sel subfield of set scalar\");\n    // If modifier tries to set a sub-field of a path expected to be a scalar.\n    F({ 'a.b': { $gt: 5, $lt: 7}, x: 1 }, { $set: { 'a.b.c': 3, x: 1 } }, \"set sub-field of $gt,$lt operator (scalar expected)\");\n    F({ 'a.b': { $gt: 5, $lt: 7}, x: 1 }, { $set: { x: 1 }, $unset: { 'a.b.c': 1 } }, \"unset sub-field of $gt,$lt operator (scalar expected)\");\n  });\n\n  Tinytest.add(\"minimongo - can selector become true by modifier - $-nonscalar selectors and simple tests\", function (t) {\n    test = t;\n    T({ a: { $eq: { x: 5 } } }, { $set: { 'a.x': 5 } }, \"set of $eq\");\n    // XXX this test should be F, but it is not implemented yet\n    T({ a: { $eq: { x: 5 } } }, { $set: { 'a.x': 4 } }, \"set of $eq\");\n    // XXX this test should be F, but it is not implemented yet\n    T({ a: { $eq: { x: 5 } } }, { $set: { 'a.y': 4 } }, \"set of $eq\");\n    T({ a: { $ne: { x: 5 } } }, { $set: { 'a.x': 3 } }, \"set of $ne\");\n    // XXX this test should be F, but it is not implemented yet\n    T({ a: { $ne: { x: 5 } } }, { $set: { 'a.x': 5 } }, \"set of $ne\");\n    T({ a: { $in: [{ b: 1 }, { b: 3 }] } }, { $set: { a: { b: 3 } } }, \"$in checks\");\n    // XXX this test should be F, but it is not implemented yet\n    T({ a: { $in: [{ b: 1 }, { b: 3 }] } }, { $set: { a: { v: 3 } } }, \"$in checks\");\n    T({ a: { $ne: { a: 2 } }, x: 1 }, { $set: { x: 1 } }, \"$ne dummy\");\n    // XXX this test should be F, but it is not implemented yet\n    T({ a: { $ne: { a: 2 } } }, { $set: { a: { a: 2 } } }, \"$ne object\");\n  });\n})();\n"]},"hash":"c9ef8a16d3c1af0944fedb9ae2d7035a99e99b47"}
