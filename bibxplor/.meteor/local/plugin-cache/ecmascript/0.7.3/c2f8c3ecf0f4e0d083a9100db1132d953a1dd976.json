{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/selector_projection.js","filenameRelative":"/packages/minimongo/selector_projection.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/selector_projection.js.map","sourceFileName":"/packages/minimongo/selector_projection.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"selector_projection"},"ignored":false,"code":"// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n  var self = this;\n\n  var selectorPaths = Minimongo._pathsElidingNumericKeys(self._getPaths()); // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n\n\n  if (_.contains(selectorPaths, '')) return {};\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\nMinimongo._pathsElidingNumericKeys = function (paths) {\n  var self = this;\n  return _.map(paths, function (path) {\n    return _.reject(path.split('.'), isNumericKey).join('.');\n  });\n};\n\ncombineImportantPathsIntoProjection = function (paths, projection) {\n  var prjDetails = projectionDetails(projection);\n  var tree = prjDetails.tree;\n  var mergedProjection = {}; // merge the paths to include\n\n  tree = pathsToTree(paths, function (path) {\n    return true;\n  }, function (node, path, fullPath) {\n    return true;\n  }, tree);\n  mergedProjection = treeToPaths(tree);\n\n  if (prjDetails.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } else {\n    // selector is pointing at fields to include\n    // projection is pointing at fields to exclude\n    // make sure we don't exclude important paths\n    var mergedExclProjection = {};\n\n    _.each(mergedProjection, function (incl, path) {\n      if (!incl) mergedExclProjection[path] = false;\n    });\n\n    return mergedExclProjection;\n  }\n}; // Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\n\n\nvar treeToPaths = function (tree, prefix) {\n  prefix = prefix || '';\n  var result = {};\n\n  _.each(tree, function (val, key) {\n    if (_.isObject(val)) _.extend(result, treeToPaths(val, prefix + key + '.'));else result[prefix + key] = val;\n  });\n\n  return result;\n};","map":{"version":3,"sources":["/packages/minimongo/selector_projection.js"],"names":["Minimongo","Matcher","prototype","combineIntoProjection","projection","self","selectorPaths","_pathsElidingNumericKeys","_getPaths","_","contains","combineImportantPathsIntoProjection","paths","map","path","reject","split","isNumericKey","join","prjDetails","projectionDetails","tree","mergedProjection","pathsToTree","node","fullPath","treeToPaths","including","mergedExclProjection","each","incl","prefix","result","val","key","isObject","extend"],"mappings":"AAAA;AACA;AACA;AACAA,UAAUC,OAAV,CAAkBC,SAAlB,CAA4BC,qBAA5B,GAAoD,UAAUC,UAAV,EAAsB;AACxE,MAAIC,OAAO,IAAX;;AACA,MAAIC,gBAAgBN,UAAUO,wBAAV,CAAmCF,KAAKG,SAAL,EAAnC,CAApB,CAFwE,CAIxE;AACA;AACA;AACA;;;AACA,MAAIC,EAAEC,QAAF,CAAWJ,aAAX,EAA0B,EAA1B,CAAJ,EACE,OAAO,EAAP;AAEF,SAAOK,oCAAoCL,aAApC,EAAmDF,UAAnD,CAAP;AACD,CAZD;;AAcAJ,UAAUO,wBAAV,GAAqC,UAAUK,KAAV,EAAiB;AACpD,MAAIP,OAAO,IAAX;AACA,SAAOI,EAAEI,GAAF,CAAMD,KAAN,EAAa,UAAUE,IAAV,EAAgB;AAClC,WAAOL,EAAEM,MAAF,CAASD,KAAKE,KAAL,CAAW,GAAX,CAAT,EAA0BC,YAA1B,EAAwCC,IAAxC,CAA6C,GAA7C,CAAP;AACD,GAFM,CAAP;AAGD,CALD;;AAOAP,sCAAsC,UAAUC,KAAV,EAAiBR,UAAjB,EAA6B;AACjE,MAAIe,aAAaC,kBAAkBhB,UAAlB,CAAjB;AACA,MAAIiB,OAAOF,WAAWE,IAAtB;AACA,MAAIC,mBAAmB,EAAvB,CAHiE,CAKjE;;AACAD,SAAOE,YAAYX,KAAZ,EACY,UAAUE,IAAV,EAAgB;AAAE,WAAO,IAAP;AAAc,GAD5C,EAEY,UAAUU,IAAV,EAAgBV,IAAhB,EAAsBW,QAAtB,EAAgC;AAAE,WAAO,IAAP;AAAc,GAF5D,EAGYJ,IAHZ,CAAP;AAIAC,qBAAmBI,YAAYL,IAAZ,CAAnB;;AACA,MAAIF,WAAWQ,SAAf,EAA0B;AACxB;AACA;AACA,WAAOL,gBAAP;AACD,GAJD,MAIO;AACL;AACA;AACA;AACA,QAAIM,uBAAuB,EAA3B;;AACAnB,MAAEoB,IAAF,CAAOP,gBAAP,EAAyB,UAAUQ,IAAV,EAAgBhB,IAAhB,EAAsB;AAC7C,UAAI,CAACgB,IAAL,EACEF,qBAAqBd,IAArB,IAA6B,KAA7B;AACH,KAHD;;AAKA,WAAOc,oBAAP;AACD;AACF,CA3BD,C,CA6BA;AACA;;;AACA,IAAIF,cAAc,UAAUL,IAAV,EAAgBU,MAAhB,EAAwB;AACxCA,WAASA,UAAU,EAAnB;AACA,MAAIC,SAAS,EAAb;;AAEAvB,IAAEoB,IAAF,CAAOR,IAAP,EAAa,UAAUY,GAAV,EAAeC,GAAf,EAAoB;AAC/B,QAAIzB,EAAE0B,QAAF,CAAWF,GAAX,CAAJ,EACExB,EAAE2B,MAAF,CAASJ,MAAT,EAAiBN,YAAYO,GAAZ,EAAiBF,SAASG,GAAT,GAAe,GAAhC,CAAjB,EADF,KAGEF,OAAOD,SAASG,GAAhB,IAAuBD,GAAvB;AACH,GALD;;AAOA,SAAOD,MAAP;AACD,CAZD","file":"/packages/minimongo/selector_projection.js.map","sourcesContent":["// Knows how to combine a mongo selector and a fields projection to a new fields\n// projection taking into account active fields from the passed selector.\n// @returns Object - projection object (same as fields option of mongo cursor)\nMinimongo.Matcher.prototype.combineIntoProjection = function (projection) {\n  var self = this;\n  var selectorPaths = Minimongo._pathsElidingNumericKeys(self._getPaths());\n\n  // Special case for $where operator in the selector - projection should depend\n  // on all fields of the document. getSelectorPaths returns a list of paths\n  // selector depends on. If one of the paths is '' (empty string) representing\n  // the root or the whole document, complete projection should be returned.\n  if (_.contains(selectorPaths, ''))\n    return {};\n\n  return combineImportantPathsIntoProjection(selectorPaths, projection);\n};\n\nMinimongo._pathsElidingNumericKeys = function (paths) {\n  var self = this;\n  return _.map(paths, function (path) {\n    return _.reject(path.split('.'), isNumericKey).join('.');\n  });\n};\n\ncombineImportantPathsIntoProjection = function (paths, projection) {\n  var prjDetails = projectionDetails(projection);\n  var tree = prjDetails.tree;\n  var mergedProjection = {};\n\n  // merge the paths to include\n  tree = pathsToTree(paths,\n                     function (path) { return true; },\n                     function (node, path, fullPath) { return true; },\n                     tree);\n  mergedProjection = treeToPaths(tree);\n  if (prjDetails.including) {\n    // both selector and projection are pointing on fields to include\n    // so we can just return the merged tree\n    return mergedProjection;\n  } else {\n    // selector is pointing at fields to include\n    // projection is pointing at fields to exclude\n    // make sure we don't exclude important paths\n    var mergedExclProjection = {};\n    _.each(mergedProjection, function (incl, path) {\n      if (!incl)\n        mergedExclProjection[path] = false;\n    });\n\n    return mergedExclProjection;\n  }\n};\n\n// Returns a set of key paths similar to\n// { 'foo.bar': 1, 'a.b.c': 1 }\nvar treeToPaths = function (tree, prefix) {\n  prefix = prefix || '';\n  var result = {};\n\n  _.each(tree, function (val, key) {\n    if (_.isObject(val))\n      _.extend(result, treeToPaths(val, prefix + key + '.'));\n    else\n      result[prefix + key] = val;\n  });\n\n  return result;\n};\n\n"]},"hash":"c2f8c3ecf0f4e0d083a9100db1132d953a1dd976"}
