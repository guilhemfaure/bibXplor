{"metadata":{"usedHelpers":[],"marked":[],"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/selector_modifier.js","filenameRelative":"/packages/minimongo/selector_modifier.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/selector_modifier.js.map","sourceFileName":"/packages/minimongo/selector_modifier.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"selector_modifier"},"ignored":false,"code":"// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n  var self = this; // safe check for $set/$unset being objects\n\n  modifier = _.extend({\n    $set: {},\n    $unset: {}\n  }, modifier);\n\n  var modifiedPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));\n\n  var meaningfulPaths = self._getPaths();\n\n  return _.any(modifiedPaths, function (path) {\n    var mod = path.split('.');\n    return _.any(meaningfulPaths, function (meaningfulPath) {\n      var sel = meaningfulPath.split('.');\n      var i = 0,\n          j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j]) i++, j++;else return false;\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j]) i++, j++;else return false;\n      } // One is a prefix of another, taking numeric fields into account\n\n\n      return true;\n    });\n  });\n}; // Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\n\n\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n  var self = this;\n  return self._selectorForAffectedByModifier.affectedByModifier(modifier);\n}; // @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\n\n\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n  var self = this;\n  if (!this.affectedByModifier(modifier)) return false;\n  modifier = _.extend({\n    $set: {},\n    $unset: {}\n  }, modifier);\n\n  var modifierPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));\n\n  if (!self.isSimple()) return true;\n  if (_.any(self._getPaths(), pathHasNumericKeys) || _.any(modifierPaths, pathHasNumericKeys)) return true; // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n\n  var expectedScalarIsObject = _.any(self._selector, function (sel, path) {\n    if (!isOperatorObject(sel)) return false;\n    return _.any(modifierPaths, function (modifierPath) {\n      return startsWith(modifierPath, path + '.');\n    });\n  });\n\n  if (expectedScalarIsObject) return false; // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n\n  var matchingDocument = EJSON.clone(self.matchingDocument()); // The selector is too complex, anything can happen.\n\n  if (matchingDocument === null) return true;\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (e) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (e.name === \"MinimongoError\" && e.setPropertyError) return false;\n    throw e;\n  }\n\n  return self.documentMatches(matchingDocument).result;\n}; // Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\n\n\nMinimongo.Matcher.prototype.matchingDocument = function () {\n  var self = this; // check if it was computed before\n\n  if (self._matchingDocument !== undefined) return self._matchingDocument; // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n\n  var fallback = false;\n  self._matchingDocument = pathsToTree(self._getPaths(), function (path) {\n    var valueSelector = self._selector[path];\n\n    if (isOperatorObject(valueSelector)) {\n      // if there is a strict equality, there is a good\n      // chance we can use one of those as \"matching\"\n      // dummy value\n      if (valueSelector.$eq) {\n        return valueSelector.$eq;\n      } else if (valueSelector.$in) {\n        var matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        }); // Return anything from $in that matches the whole selector for this\n        // path. If nothing matches, returns `undefined` as nothing can make\n        // this selector into `true`.\n\n        return _.find(valueSelector.$in, function (x) {\n          return matcher.documentMatches({\n            placeholder: x\n          }).result;\n        });\n      } else if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n        var lowerBound = -Infinity,\n            upperBound = Infinity;\n\n        _.each(['$lte', '$lt'], function (op) {\n          if (_.has(valueSelector, op) && valueSelector[op] < upperBound) upperBound = valueSelector[op];\n        });\n\n        _.each(['$gte', '$gt'], function (op) {\n          if (_.has(valueSelector, op) && valueSelector[op] > lowerBound) lowerBound = valueSelector[op];\n        });\n\n        var middle = (lowerBound + upperBound) / 2;\n        var matcher = new Minimongo.Matcher({\n          placeholder: valueSelector\n        });\n        if (!matcher.documentMatches({\n          placeholder: middle\n        }).result && (middle === lowerBound || middle === upperBound)) fallback = true;\n        return middle;\n      } else if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n        // Since self._isSimple makes sure $nin and $ne are not combined with\n        // objects or arrays, we can confidently return an empty object as it\n        // never matches any scalar.\n        return {};\n      } else {\n        fallback = true;\n      }\n    }\n\n    return self._selector[path];\n  }, _.identity /*conflict resolution is no resolution*/);\n  if (fallback) self._matchingDocument = null;\n  return self._matchingDocument;\n};\n\nvar getPaths = function (sel) {\n  return _.keys(new Minimongo.Matcher(sel)._paths);\n  return _.chain(sel).map(function (v, k) {\n    // we don't know how to handle $where because it can be anything\n    if (k === \"$where\") return ''; // matches everything\n    // we branch from $or/$and/$nor operator\n\n    if (_.contains(['$or', '$and', '$nor'], k)) return _.map(v, getPaths); // the value is a literal or some comparison operator\n\n    return k;\n  }).flatten().uniq().value();\n}; // A helper to ensure object has only certain keys\n\n\nvar onlyContainsKeys = function (obj, keys) {\n  return _.all(obj, function (v, k) {\n    return _.contains(keys, k);\n  });\n};\n\nvar pathHasNumericKeys = function (path) {\n  return _.any(path.split('.'), isNumericKey);\n}; // XXX from Underscore.String (http://epeli.github.com/underscore.string/)\n\n\nvar startsWith = function (str, starts) {\n  return str.length >= starts.length && str.substring(0, starts.length) === starts;\n};","map":{"version":3,"sources":["/packages/minimongo/selector_modifier.js"],"names":["Minimongo","Matcher","prototype","affectedByModifier","modifier","self","_","extend","$set","$unset","modifiedPaths","keys","concat","meaningfulPaths","_getPaths","any","path","mod","split","meaningfulPath","sel","i","j","length","isNumericKey","Sorter","_selectorForAffectedByModifier","canBecomeTrueByModifier","modifierPaths","isSimple","pathHasNumericKeys","expectedScalarIsObject","_selector","isOperatorObject","modifierPath","startsWith","matchingDocument","EJSON","clone","LocalCollection","_modify","e","name","setPropertyError","documentMatches","result","_matchingDocument","undefined","fallback","pathsToTree","valueSelector","$eq","$in","matcher","placeholder","find","x","onlyContainsKeys","lowerBound","Infinity","upperBound","each","op","has","middle","identity","getPaths","_paths","chain","map","v","k","contains","flatten","uniq","value","obj","all","str","starts","substring"],"mappings":"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","file":"/packages/minimongo/selector_modifier.js.map","sourcesContent":["// Returns true if the modifier applied to some document may change the result\n// of matching the document by selector\n// The modifier is always in a form of Object:\n//  - $set\n//    - 'a.b.22.z': value\n//    - 'foo.bar': 42\n//  - $unset\n//    - 'abc.d': 1\nMinimongo.Matcher.prototype.affectedByModifier = function (modifier) {\n  var self = this;\n  // safe check for $set/$unset being objects\n  modifier = _.extend({ $set: {}, $unset: {} }, modifier);\n  var modifiedPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));\n  var meaningfulPaths = self._getPaths();\n\n  return _.any(modifiedPaths, function (path) {\n    var mod = path.split('.');\n    return _.any(meaningfulPaths, function (meaningfulPath) {\n      var sel = meaningfulPath.split('.');\n      var i = 0, j = 0;\n\n      while (i < sel.length && j < mod.length) {\n        if (isNumericKey(sel[i]) && isNumericKey(mod[j])) {\n          // foo.4.bar selector affected by foo.4 modifier\n          // foo.3.bar selector unaffected by foo.4 modifier\n          if (sel[i] === mod[j])\n            i++, j++;\n          else\n            return false;\n        } else if (isNumericKey(sel[i])) {\n          // foo.4.bar selector unaffected by foo.bar modifier\n          return false;\n        } else if (isNumericKey(mod[j])) {\n          j++;\n        } else if (sel[i] === mod[j])\n          i++, j++;\n        else\n          return false;\n      }\n\n      // One is a prefix of another, taking numeric fields into account\n      return true;\n    });\n  });\n};\n\n// Minimongo.Sorter gets a similar method, which delegates to a Matcher it made\n// for this exact purpose.\nMinimongo.Sorter.prototype.affectedByModifier = function (modifier) {\n  var self = this;\n  return self._selectorForAffectedByModifier.affectedByModifier(modifier);\n};\n\n// @param modifier - Object: MongoDB-styled modifier with `$set`s and `$unsets`\n//                           only. (assumed to come from oplog)\n// @returns - Boolean: if after applying the modifier, selector can start\n//                     accepting the modified value.\n// NOTE: assumes that document affected by modifier didn't match this Matcher\n// before, so if modifier can't convince selector in a positive change it would\n// stay 'false'.\n// Currently doesn't support $-operators and numeric indices precisely.\nMinimongo.Matcher.prototype.canBecomeTrueByModifier = function (modifier) {\n  var self = this;\n  if (!this.affectedByModifier(modifier))\n    return false;\n\n  modifier = _.extend({$set:{}, $unset:{}}, modifier);\n  var modifierPaths = _.keys(modifier.$set).concat(_.keys(modifier.$unset));\n\n  if (!self.isSimple())\n    return true;\n\n  if (_.any(self._getPaths(), pathHasNumericKeys) ||\n      _.any(modifierPaths, pathHasNumericKeys))\n    return true;\n\n  // check if there is a $set or $unset that indicates something is an\n  // object rather than a scalar in the actual object where we saw $-operator\n  // NOTE: it is correct since we allow only scalars in $-operators\n  // Example: for selector {'a.b': {$gt: 5}} the modifier {'a.b.c':7} would\n  // definitely set the result to false as 'a.b' appears to be an object.\n  var expectedScalarIsObject = _.any(self._selector, function (sel, path) {\n    if (! isOperatorObject(sel))\n      return false;\n    return _.any(modifierPaths, function (modifierPath) {\n      return startsWith(modifierPath, path + '.');\n    });\n  });\n\n  if (expectedScalarIsObject)\n    return false;\n\n  // See if we can apply the modifier on the ideally matching object. If it\n  // still matches the selector, then the modifier could have turned the real\n  // object in the database into something matching.\n  var matchingDocument = EJSON.clone(self.matchingDocument());\n\n  // The selector is too complex, anything can happen.\n  if (matchingDocument === null)\n    return true;\n\n  try {\n    LocalCollection._modify(matchingDocument, modifier);\n  } catch (e) {\n    // Couldn't set a property on a field which is a scalar or null in the\n    // selector.\n    // Example:\n    // real document: { 'a.b': 3 }\n    // selector: { 'a': 12 }\n    // converted selector (ideal document): { 'a': 12 }\n    // modifier: { $set: { 'a.b': 4 } }\n    // We don't know what real document was like but from the error raised by\n    // $set on a scalar field we can reason that the structure of real document\n    // is completely different.\n    if (e.name === \"MinimongoError\" && e.setPropertyError)\n      return false;\n    throw e;\n  }\n\n  return self.documentMatches(matchingDocument).result;\n};\n\n// Returns an object that would match the selector if possible or null if the\n// selector is too complex for us to analyze\n// { 'a.b': { ans: 42 }, 'foo.bar': null, 'foo.baz': \"something\" }\n// => { a: { b: { ans: 42 } }, foo: { bar: null, baz: \"something\" } }\nMinimongo.Matcher.prototype.matchingDocument = function () {\n  var self = this;\n\n  // check if it was computed before\n  if (self._matchingDocument !== undefined)\n    return self._matchingDocument;\n\n  // If the analysis of this selector is too hard for our implementation\n  // fallback to \"YES\"\n  var fallback = false;\n  self._matchingDocument = pathsToTree(self._getPaths(),\n    function (path) {\n      var valueSelector = self._selector[path];\n      if (isOperatorObject(valueSelector)) {\n        // if there is a strict equality, there is a good\n        // chance we can use one of those as \"matching\"\n        // dummy value\n        if (valueSelector.$eq) {\n          return valueSelector.$eq;\n        } else if (valueSelector.$in) {\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });\n\n          // Return anything from $in that matches the whole selector for this\n          // path. If nothing matches, returns `undefined` as nothing can make\n          // this selector into `true`.\n          return _.find(valueSelector.$in, function (x) {\n            return matcher.documentMatches({ placeholder: x }).result;\n          });\n        } else if (onlyContainsKeys(valueSelector, ['$gt', '$gte', '$lt', '$lte'])) {\n          var lowerBound = -Infinity, upperBound = Infinity;\n          _.each(['$lte', '$lt'], function (op) {\n            if (_.has(valueSelector, op) && valueSelector[op] < upperBound)\n              upperBound = valueSelector[op];\n          });\n          _.each(['$gte', '$gt'], function (op) {\n            if (_.has(valueSelector, op) && valueSelector[op] > lowerBound)\n              lowerBound = valueSelector[op];\n          });\n\n          var middle = (lowerBound + upperBound) / 2;\n          var matcher = new Minimongo.Matcher({ placeholder: valueSelector });\n          if (!matcher.documentMatches({ placeholder: middle }).result &&\n              (middle === lowerBound || middle === upperBound))\n            fallback = true;\n\n          return middle;\n        } else if (onlyContainsKeys(valueSelector, ['$nin', '$ne'])) {\n          // Since self._isSimple makes sure $nin and $ne are not combined with\n          // objects or arrays, we can confidently return an empty object as it\n          // never matches any scalar.\n          return {};\n        } else {\n          fallback = true;\n        }\n      }\n      return self._selector[path];\n    },\n    _.identity /*conflict resolution is no resolution*/);\n\n  if (fallback)\n    self._matchingDocument = null;\n\n  return self._matchingDocument;\n};\n\nvar getPaths = function (sel) {\n  return _.keys(new Minimongo.Matcher(sel)._paths);\n  return _.chain(sel).map(function (v, k) {\n    // we don't know how to handle $where because it can be anything\n    if (k === \"$where\")\n      return ''; // matches everything\n    // we branch from $or/$and/$nor operator\n    if (_.contains(['$or', '$and', '$nor'], k))\n      return _.map(v, getPaths);\n    // the value is a literal or some comparison operator\n    return k;\n  }).flatten().uniq().value();\n};\n\n// A helper to ensure object has only certain keys\nvar onlyContainsKeys = function (obj, keys) {\n  return _.all(obj, function (v, k) {\n    return _.contains(keys, k);\n  });\n};\n\nvar pathHasNumericKeys = function (path) {\n  return _.any(path.split('.'), isNumericKey);\n}\n\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\n"]},"hash":"0fd2b8bad762d5423539ffb6d398d00f71662c76"}
