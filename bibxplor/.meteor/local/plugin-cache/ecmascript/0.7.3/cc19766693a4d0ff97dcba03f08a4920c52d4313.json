{"metadata":{"usedHelpers":["typeof","interopRequireDefault"],"marked":[],"modules":{"imports":[{"source":"./validation.js","imported":["assertHasValidFieldNames","assertIsValidFieldName"],"specifiers":[{"kind":"named","imported":"assertHasValidFieldNames","local":"assertHasValidFieldNames"},{"kind":"named","imported":"assertIsValidFieldName","local":"assertIsValidFieldName"}]}],"exports":{"exported":[],"specifiers":[]}}},"options":{"filename":"/packages/minimongo/modify.js","filenameRelative":"/packages/minimongo/modify.js","env":{"development":{"plugins":[]}},"retainLines":false,"highlightCode":true,"suppressDeprecationMessages":false,"presets":[],"plugins":[[[],{"generateLetDeclarations":true,"enforceStrictMode":false}],[[],null],[[],{"polyfill":false}],[[],null],[[],null],[[],{"allowTopLevelThis":true,"strict":false,"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],{"loose":true}],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],{"loose":true}],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null],[[],null]],"ignore":[],"code":true,"metadata":true,"ast":true,"comments":true,"compact":false,"minified":false,"sourceMap":true,"sourceMaps":true,"sourceMapTarget":"/packages/minimongo/modify.js.map","sourceFileName":"/packages/minimongo/modify.js","babelrc":false,"sourceType":"module","moduleIds":false,"passPerPreset":false,"parserOpts":false,"generatorOpts":false,"basename":"modify"},"ignored":false,"code":"var _typeof2 = require(\"babel-runtime/helpers/typeof\");\n\nvar _typeof3 = _interopRequireDefault(_typeof2);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { \"default\": obj }; }\n\nvar assertHasValidFieldNames = void 0,\n    assertIsValidFieldName = void 0;\nmodule.importSync(\"./validation.js\", {\n  assertHasValidFieldNames: function (v) {\n    assertHasValidFieldNames = v;\n  },\n  assertIsValidFieldName: function (v) {\n    assertIsValidFieldName = v;\n  }\n}, 0);\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod)) throw MinimongoError(\"Modifier must be an object\"); // Make sure the caller can't mutate our data structures.\n\n  mod = EJSON.clone(mod);\n  var isModifier = isOperatorObject(mod);\n  var newDoc;\n\n  if (!isModifier) {\n    if (mod._id && !EJSON.equals(doc._id, mod._id)) throw MinimongoError(\"Cannot change the _id of a document\"); // replace the whole document\n\n    assertHasValidFieldNames(mod);\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = EJSON.clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op]; // Treat $setOnInsert as $set if this is an insert.\n\n      if (options.isInsert && op === '$setOnInsert') modFunc = MODIFIERS['$set'];\n      if (!modFunc) throw MinimongoError(\"Invalid modifier specified \" + op);\n\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw MinimongoError(\"An empty update path is not valid.\");\n        }\n\n        if (keypath === '_id' && op !== '$setOnInsert') {\n          throw MinimongoError(\"Mod on _id not allowed\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (!_.all(keyparts, _.identity)) {\n          throw MinimongoError(\"The update path '\" + keypath + \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);\n\n        var forbidArray = op === \"$rename\";\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: op === \"$rename\",\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  } // move new document into place.\n\n\n  _.each(_.keys(doc), function (k) {\n    // Note: this used to be for (var k in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (k !== '_id') delete doc[k];\n  });\n\n  _.each(newDoc, function (v, k) {\n    doc[k] = v;\n  });\n}; // for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\n\n\nvar findModTarget = function (doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = i === keyparts.length - 1;\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n\n    if (!indexable) {\n      if (options.noCreate) return undefined;\n      var e = MinimongoError(\"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (doc instanceof Array) {\n      if (options.forbidArray) return null;\n\n      if (keypart === '$') {\n        if (usedArrayIndex) throw MinimongoError(\"Too many positional (i.e. '$') elements\");\n\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\"The positional operator did not find the \" + \"match needed from the query\");\n        }\n\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate) return undefined;\n        throw MinimongoError(\"can't append to array using string field name [\" + keypart + \"]\");\n      }\n\n      if (last) // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length) return undefined;\n\n      while (doc.length < keypart) {\n        doc.push(null);\n      }\n\n      if (!last) {\n        if (doc.length === keypart) doc.push({});else if ((0, _typeof3.default)(doc[keypart]) !== \"object\") throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] + \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n\n      if (!(keypart in doc)) {\n        if (options.noCreate) return undefined;\n        if (!last) doc[keypart] = {};\n      }\n    }\n\n    if (last) return doc;\n    doc = doc[keypart];\n  } // notreached\n\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if ((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg.hasOwnProperty(\"$type\")) {\n      if (arg.$type !== \"date\") {\n        throw MinimongoError(\"Minimongo does currently only support the date type \" + \"in $currentDate modifiers\", {\n          field: field\n        });\n      }\n    } else if (arg !== true) {\n      throw MinimongoError(\"Invalid $currentDate modifier\", {\n        field: field\n      });\n    }\n\n    target[field] = new Date();\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $min allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $min modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $max allowed for numbers only\", {\n        field: field\n      });\n    }\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\"Cannot apply $max modifier to non-number\", {\n          field: field\n        });\n      }\n\n      if (target[field] < arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== \"number\") throw MinimongoError(\"Modifier $inc allowed for numbers only\", {\n      field: field\n    });\n\n    if (field in target) {\n      if (typeof target[field] !== \"number\") throw MinimongoError(\"Cannot apply $inc modifier to non-number\", {\n        field: field\n      });\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function (target, field, arg) {\n    if (!_.isObject(target)) {\n      // not an array or an object\n      var e = MinimongoError(\"Cannot set property on non-object field\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    if (target === null) {\n      var e = MinimongoError(\"Cannot set property on null\", {\n        field: field\n      });\n      e.setPropertyError = true;\n      throw e;\n    }\n\n    assertHasValidFieldNames(arg);\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {// converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target) target[field] = null;\n      } else delete target[field];\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined) target[field] = [];\n    if (!(target[field] instanceof Array)) throw MinimongoError(\"Cannot apply $push modifier to non-array\", {\n      field: field\n    });\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n      target[field].push(arg);\n      return;\n    } // Fancy mode: $each (and maybe $slice and $sort and $position)\n\n\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array)) throw MinimongoError(\"$each must be an array\", {\n      field: field\n    });\n    assertHasValidFieldNames(toPush); // Parse $position\n\n    var position = undefined;\n\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\") throw MinimongoError(\"$position must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$position < 0) throw MinimongoError(\"$position in $push must be zero or positive\", {\n        field: field\n      });\n      position = arg.$position;\n    } // Parse $slice.\n\n\n    var slice = undefined;\n\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\") throw MinimongoError(\"$slice must be a numeric value\", {\n        field: field\n      }); // XXX should check to make sure integer\n\n      if (arg.$slice > 0) throw MinimongoError(\"$slice in $push must be zero or negative\", {\n        field: field\n      });\n      slice = arg.$slice;\n    } // Parse $sort.\n\n\n    var sortFunction = undefined;\n\n    if (arg.$sort) {\n      if (slice === undefined) throw MinimongoError(\"$sort requires $slice to be present\", {\n        field: field\n      }); // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n\n      for (var i = 0; i < toPush.length; i++) {\n        if (LocalCollection._f._type(toPush[i]) !== 3) {\n          throw MinimongoError(\"$push like modifiers using $sort \" + \"require all elements to be objects\", {\n            field: field\n          });\n        }\n      }\n    } // Actually push.\n\n\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++) {\n        target[field].push(toPush[j]);\n      }\n    } else {\n      var spliceArguments = [position, 0];\n\n      for (var j = 0; j < toPush.length; j++) {\n        spliceArguments.push(toPush[j]);\n      }\n\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    } // Actually sort.\n\n\n    if (sortFunction) target[field].sort(sortFunction); // Actually slice.\n\n    if (slice !== undefined) {\n      if (slice === 0) target[field] = []; // differs from Array.slice!\n      else target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg instanceof Array)) throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    assertHasValidFieldNames(arg);\n    var x = target[field];\n    if (x === undefined) target[field] = arg;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pushAll modifier to non-array\", {\n      field: field\n    });else {\n      for (var i = 0; i < arg.length; i++) {\n        x.push(arg[i]);\n      }\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n\n    if ((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\") {\n      //check if first key is '$each'\n      var keys = Object.keys(arg);\n\n      if (keys[0] === \"$each\") {\n        isEach = true;\n      }\n    }\n\n    var values = isEach ? arg[\"$each\"] : [arg];\n    assertHasValidFieldNames(values);\n    var x = target[field];\n    if (x === undefined) target[field] = values;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $addToSet modifier to non-array\", {\n      field: field\n    });else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++) {\n          if (LocalCollection._f._equal(value, x[i])) return;\n        }\n\n        x.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pop modifier to non-array\", {\n      field: field\n    });else {\n      if (typeof arg === 'number' && arg < 0) x.splice(0, 1);else x.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      var out = [];\n\n      if (arg != null && (typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new Minimongo.Matcher(arg);\n\n        for (var i = 0; i < x.length; i++) {\n          if (!matcher.documentMatches(x[i]).result) out.push(x[i]);\n        }\n      } else {\n        for (var i = 0; i < x.length; i++) {\n          if (!LocalCollection._f._equal(x[i], arg)) out.push(x[i]);\n        }\n      }\n\n      target[field] = out;\n    }\n  },\n  $pullAll: function (target, field, arg) {\n    if (!((typeof arg === \"undefined\" ? \"undefined\" : (0, _typeof3.default)(arg)) === \"object\" && arg instanceof Array)) throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\", {\n      field: field\n    });\n    if (target === undefined) return;\n    var x = target[field];\n    if (x === undefined) return;else if (!(x instanceof Array)) throw MinimongoError(\"Cannot apply $pull/pullAll modifier to non-array\", {\n      field: field\n    });else {\n      var out = [];\n\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n\n        for (var j = 0; j < arg.length; j++) {\n          if (LocalCollection._f._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n\n        if (!exclude) out.push(x[i]);\n      }\n\n      target[field] = out;\n    }\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    if (keypath === arg) // no idea why mongo has this restriction..\n      throw MinimongoError(\"$rename source must differ from target\", {\n        field: field\n      });\n    if (target === null) throw MinimongoError(\"$rename source field invalid\", {\n      field: field\n    });\n    if (typeof arg !== \"string\") throw MinimongoError(\"$rename target must be a string\", {\n      field: field\n    });\n\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\"The 'to' field for $rename cannot contain an embedded null byte\", {\n        field: field\n      });\n    }\n\n    if (target === undefined) return;\n    var v = target[field];\n    delete target[field];\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {\n      forbidArray: true\n    });\n    if (target2 === null) throw MinimongoError(\"$rename target field invalid\", {\n      field: field\n    });\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError(\"$bit is not supported\", {\n      field: field\n    });\n  }\n};","map":{"version":3,"sources":["/packages/minimongo/modify.js"],"names":["assertHasValidFieldNames","assertIsValidFieldName","module","importSync","v","LocalCollection","_modify","doc","mod","options","isPlainObject","MinimongoError","EJSON","clone","isModifier","isOperatorObject","newDoc","_id","equals","_","each","operand","op","modFunc","MODIFIERS","isInsert","arg","keypath","keyparts","split","all","identity","noCreate","has","NO_CREATE_MODIFIERS","forbidArray","target","findModTarget","arrayIndices","field","pop","keys","k","usedArrayIndex","i","length","last","keypart","indexable","isIndexable","undefined","e","setPropertyError","Array","isNumericKey","parseInt","push","JSON","stringify","$unset","$pop","$rename","$pull","$pullAll","$currentDate","hasOwnProperty","$type","Date","$min","$max","$inc","$set","isObject","$setOnInsert","$push","$each","toPush","position","$position","slice","$slice","sortFunction","$sort","Minimongo","Sorter","getComparator","_f","_type","j","spliceArguments","prototype","splice","apply","sort","$pushAll","x","$addToSet","isEach","Object","values","value","_equal","out","matcher","Matcher","documentMatches","result","exclude","indexOf","target2","field2","$bit"],"mappings":";;;;;;AAAA,IAAIA,iCAAJ;AAAA,IAA6BC,+BAA7B;AAAoDC,OAAOC,UAAP,CAAkB,iBAAlB,EAAoC;AAACH,4BAAyB,UAASI,CAAT,EAAW;AAACJ,+BAAyBI,CAAzB;AAA2B,GAAjE;AAAkEH,0BAAuB,UAASG,CAAT,EAAW;AAACH,6BAAuBG,CAAvB;AAAyB;AAA9H,CAApC,EAAoK,CAApK;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAC,gBAAgBC,OAAhB,GAA0B,UAAUC,GAAV,EAAeC,GAAf,EAAoBC,OAApB,EAA6B;AACrDA,YAAUA,WAAW,EAArB;AACA,MAAI,CAACC,cAAcF,GAAd,CAAL,EACE,MAAMG,eAAe,4BAAf,CAAN,CAHmD,CAKrD;;AACAH,QAAMI,MAAMC,KAAN,CAAYL,GAAZ,CAAN;AAEA,MAAIM,aAAaC,iBAAiBP,GAAjB,CAAjB;AAEA,MAAIQ,MAAJ;;AAEA,MAAI,CAACF,UAAL,EAAiB;AACf,QAAIN,IAAIS,GAAJ,IAAW,CAACL,MAAMM,MAAN,CAAaX,IAAIU,GAAjB,EAAsBT,IAAIS,GAA1B,CAAhB,EACE,MAAMN,eAAe,qCAAf,CAAN,CAFa,CAIf;;AACAX,6BAAyBQ,GAAzB;AACAQ,aAASR,GAAT;AACD,GAPD,MAOO;AACL;AACAQ,aAASJ,MAAMC,KAAN,CAAYN,GAAZ,CAAT;;AAEAY,MAAEC,IAAF,CAAOZ,GAAP,EAAY,UAAUa,OAAV,EAAmBC,EAAnB,EAAuB;AACjC,UAAIC,UAAUC,UAAUF,EAAV,CAAd,CADiC,CAEjC;;AACA,UAAIb,QAAQgB,QAAR,IAAoBH,OAAO,cAA/B,EACEC,UAAUC,UAAU,MAAV,CAAV;AACF,UAAI,CAACD,OAAL,EACE,MAAMZ,eAAe,gCAAgCW,EAA/C,CAAN;;AACFH,QAAEC,IAAF,CAAOC,OAAP,EAAgB,UAAUK,GAAV,EAAeC,OAAf,EAAwB;AACtC,YAAIA,YAAY,EAAhB,EAAoB;AAClB,gBAAMhB,eAAe,oCAAf,CAAN;AACD;;AAED,YAAIgB,YAAY,KAAZ,IAAqBL,OAAO,cAAhC,EAAgD;AAC9C,gBAAMX,eAAe,wBAAf,CAAN;AACD;;AAED,YAAIiB,WAAWD,QAAQE,KAAR,CAAc,GAAd,CAAf;;AAEA,YAAI,CAAEV,EAAEW,GAAF,CAAMF,QAAN,EAAgBT,EAAEY,QAAlB,CAAN,EAAmC;AACjC,gBAAMpB,eACJ,sBAAsBgB,OAAtB,GACE,uDAFE,CAAN;AAGD;;AAED,YAAIK,WAAWb,EAAEc,GAAF,CAAMC,mBAAN,EAA2BZ,EAA3B,CAAf;;AACA,YAAIa,cAAeb,OAAO,SAA1B;AACA,YAAIc,SAASC,cAAcrB,MAAd,EAAsBY,QAAtB,EAAgC;AAC3CI,oBAAUE,oBAAoBZ,EAApB,CADiC;AAE3Ca,uBAAcb,OAAO,SAFsB;AAG3CgB,wBAAc7B,QAAQ6B;AAHqB,SAAhC,CAAb;AAKA,YAAIC,QAAQX,SAASY,GAAT,EAAZ;AACAjB,gBAAQa,MAAR,EAAgBG,KAAhB,EAAuBb,GAAvB,EAA4BC,OAA5B,EAAqCX,MAArC;AACD,OA1BD;AA2BD,KAlCD;AAmCD,GA1DoD,CA4DrD;;;AACAG,IAAEC,IAAF,CAAOD,EAAEsB,IAAF,CAAOlC,GAAP,CAAP,EAAoB,UAAUmC,CAAV,EAAa;AAC/B;AACA;AACA;AACA,QAAIA,MAAM,KAAV,EACE,OAAOnC,IAAImC,CAAJ,CAAP;AACH,GAND;;AAOAvB,IAAEC,IAAF,CAAOJ,MAAP,EAAe,UAAUZ,CAAV,EAAasC,CAAb,EAAgB;AAC7BnC,QAAImC,CAAJ,IAAStC,CAAT;AACD,GAFD;AAGD,CAvED,C,CAyEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAIiC,gBAAgB,UAAU9B,GAAV,EAAeqB,QAAf,EAAyBnB,OAAzB,EAAkC;AACpDA,YAAUA,WAAW,EAArB;AACA,MAAIkC,iBAAiB,KAArB;;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIhB,SAASiB,MAA7B,EAAqCD,GAArC,EAA0C;AACxC,QAAIE,OAAQF,MAAMhB,SAASiB,MAAT,GAAkB,CAApC;AACA,QAAIE,UAAUnB,SAASgB,CAAT,CAAd;AACA,QAAII,YAAYC,YAAY1C,GAAZ,CAAhB;;AACA,QAAI,CAACyC,SAAL,EAAgB;AACd,UAAIvC,QAAQuB,QAAZ,EACE,OAAOkB,SAAP;AACF,UAAIC,IAAIxC,eACN,0BAA0BoC,OAA1B,GAAoC,gBAApC,GAAuDxC,GADjD,CAAR;AAEA4C,QAAEC,gBAAF,GAAqB,IAArB;AACA,YAAMD,CAAN;AACD;;AACD,QAAI5C,eAAe8C,KAAnB,EAA0B;AACxB,UAAI5C,QAAQ0B,WAAZ,EACE,OAAO,IAAP;;AACF,UAAIY,YAAY,GAAhB,EAAqB;AACnB,YAAIJ,cAAJ,EACE,MAAMhC,eAAe,yCAAf,CAAN;;AACF,YAAI,CAACF,QAAQ6B,YAAT,IAAyB,CAAC7B,QAAQ6B,YAAR,CAAqBO,MAAnD,EAA2D;AACzD,gBAAMlC,eAAe,8CACA,6BADf,CAAN;AAED;;AACDoC,kBAAUtC,QAAQ6B,YAAR,CAAqB,CAArB,CAAV;AACAK,yBAAiB,IAAjB;AACD,OATD,MASO,IAAIW,aAAaP,OAAb,CAAJ,EAA2B;AAChCA,kBAAUQ,SAASR,OAAT,CAAV;AACD,OAFM,MAEA;AACL,YAAItC,QAAQuB,QAAZ,EACE,OAAOkB,SAAP;AACF,cAAMvC,eACJ,oDACYoC,OADZ,GACsB,GAFlB,CAAN;AAGD;;AACD,UAAID,IAAJ,EACE;AACAlB,iBAASgB,CAAT,IAAcG,OAAd;AACF,UAAItC,QAAQuB,QAAR,IAAoBe,WAAWxC,IAAIsC,MAAvC,EACE,OAAOK,SAAP;;AACF,aAAO3C,IAAIsC,MAAJ,GAAaE,OAApB;AACExC,YAAIiD,IAAJ,CAAS,IAAT;AADF;;AAEA,UAAI,CAACV,IAAL,EAAW;AACT,YAAIvC,IAAIsC,MAAJ,KAAeE,OAAnB,EACExC,IAAIiD,IAAJ,CAAS,EAAT,EADF,KAEK,IAAI,sBAAOjD,IAAIwC,OAAJ,CAAP,MAAwB,QAA5B,EACH,MAAMpC,eAAe,yBAAyBiB,SAASgB,IAAI,CAAb,CAAzB,GACT,kBADS,GACYa,KAAKC,SAAL,CAAenD,IAAIwC,OAAJ,CAAf,CAD3B,CAAN;AAEH;AACF,KAnCD,MAmCO;AACL9C,6BAAuB8C,OAAvB;;AACA,UAAI,EAAEA,WAAWxC,GAAb,CAAJ,EAAuB;AACrB,YAAIE,QAAQuB,QAAZ,EACE,OAAOkB,SAAP;AACF,YAAI,CAACJ,IAAL,EACEvC,IAAIwC,OAAJ,IAAe,EAAf;AACH;AACF;;AAED,QAAID,IAAJ,EACE,OAAOvC,GAAP;AACFA,UAAMA,IAAIwC,OAAJ,CAAN;AACD,GA/DmD,CAiEpD;;AACD,CAlED;;AAoEA,IAAIb,sBAAsB;AACxByB,UAAQ,IADgB;AAExBC,QAAM,IAFkB;AAGxBC,WAAS,IAHe;AAIxBC,SAAO,IAJiB;AAKxBC,YAAU;AALc,CAA1B;AAQA,IAAIvC,YAAY;AACdwC,gBAAc,UAAU5B,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAC1C,QAAI,QAAOA,GAAP,uDAAOA,GAAP,OAAe,QAAf,IAA2BA,IAAIuC,cAAJ,CAAmB,OAAnB,CAA/B,EAA4D;AACzD,UAAIvC,IAAIwC,KAAJ,KAAc,MAAlB,EAA0B;AACvB,cAAMvD,eACJ,yDACA,2BAFI,EAGJ;AAAE4B;AAAF,SAHI,CAAN;AAIF;AACH,KAPD,MAOO,IAAIb,QAAQ,IAAZ,EAAkB;AACvB,YAAMf,eAAe,+BAAf,EAAgD;AAAE4B;AAAF,OAAhD,CAAN;AACD;;AACDH,WAAOG,KAAP,IAAgB,IAAI4B,IAAJ,EAAhB;AACD,GAba;AAcdC,QAAM,UAAUhC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAMf,eAAe,wCAAf,EAAyD;AAAE4B;AAAF,OAAzD,CAAN;AACD;;AACD,QAAIA,SAASH,MAAb,EAAqB;AACnB,UAAI,OAAOA,OAAOG,KAAP,CAAP,KAAyB,QAA7B,EAAuC;AACrC,cAAM5B,eACJ,0CADI,EACwC;AAAE4B;AAAF,SADxC,CAAN;AAED;;AACD,UAAIH,OAAOG,KAAP,IAAgBb,GAApB,EAAyB;AACvBU,eAAOG,KAAP,IAAgBb,GAAhB;AACD;AACF,KARD,MAQO;AACLU,aAAOG,KAAP,IAAgBb,GAAhB;AACD;AACF,GA7Ba;AA8Bd2C,QAAM,UAAUjC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC,QAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;AAC3B,YAAMf,eAAe,wCAAf,EAAyD;AAAE4B;AAAF,OAAzD,CAAN;AACD;;AACD,QAAIA,SAASH,MAAb,EAAqB;AACnB,UAAI,OAAOA,OAAOG,KAAP,CAAP,KAAyB,QAA7B,EAAuC;AACrC,cAAM5B,eACJ,0CADI,EACwC;AAAE4B;AAAF,SADxC,CAAN;AAED;;AACD,UAAIH,OAAOG,KAAP,IAAgBb,GAApB,EAAyB;AACtBU,eAAOG,KAAP,IAAgBb,GAAhB;AACF;AACF,KARD,MAQO;AACLU,aAAOG,KAAP,IAAgBb,GAAhB;AACD;AACF,GA7Ca;AA8Cd4C,QAAM,UAAUlC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC,QAAI,OAAOA,GAAP,KAAe,QAAnB,EACE,MAAMf,eAAe,wCAAf,EAAyD;AAAE4B;AAAF,KAAzD,CAAN;;AACF,QAAIA,SAASH,MAAb,EAAqB;AACnB,UAAI,OAAOA,OAAOG,KAAP,CAAP,KAAyB,QAA7B,EACE,MAAM5B,eACJ,0CADI,EACwC;AAAE4B;AAAF,OADxC,CAAN;AAEFH,aAAOG,KAAP,KAAiBb,GAAjB;AACD,KALD,MAKO;AACLU,aAAOG,KAAP,IAAgBb,GAAhB;AACD;AACF,GAzDa;AA0Dd6C,QAAM,UAAUnC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC,QAAI,CAACP,EAAEqD,QAAF,CAAWpC,MAAX,CAAL,EAAyB;AAAE;AACzB,UAAIe,IAAIxC,eACN,yCADM,EACqC;AAAE4B;AAAF,OADrC,CAAR;AAEAY,QAAEC,gBAAF,GAAqB,IAArB;AACA,YAAMD,CAAN;AACD;;AACD,QAAIf,WAAW,IAAf,EAAqB;AACnB,UAAIe,IAAIxC,eAAe,6BAAf,EAA8C;AAAE4B;AAAF,OAA9C,CAAR;AACAY,QAAEC,gBAAF,GAAqB,IAArB;AACA,YAAMD,CAAN;AACD;;AACDnD,6BAAyB0B,GAAzB;AACAU,WAAOG,KAAP,IAAgBb,GAAhB;AACD,GAxEa;AAyEd+C,gBAAc,UAAUrC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B,CAC1C;AACD,GA3Ea;AA4EdiC,UAAQ,UAAUvB,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACpC,QAAIU,WAAWc,SAAf,EAA0B;AACxB,UAAId,kBAAkBiB,KAAtB,EAA6B;AAC3B,YAAId,SAASH,MAAb,EACEA,OAAOG,KAAP,IAAgB,IAAhB;AACH,OAHD,MAIE,OAAOH,OAAOG,KAAP,CAAP;AACH;AACF,GApFa;AAqFdmC,SAAO,UAAUtC,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACnC,QAAIU,OAAOG,KAAP,MAAkBW,SAAtB,EACEd,OAAOG,KAAP,IAAgB,EAAhB;AACF,QAAI,EAAEH,OAAOG,KAAP,aAAyBc,KAA3B,CAAJ,EACE,MAAM1C,eACJ,0CADI,EACwC;AAAE4B;AAAF,KADxC,CAAN;;AAGF,QAAI,EAAEb,OAAOA,IAAIiD,KAAb,CAAJ,EAAyB;AACvB;AACA3E,+BAAyB0B,GAAzB;AACAU,aAAOG,KAAP,EAAciB,IAAd,CAAmB9B,GAAnB;AACA;AACD,KAZkC,CAcnC;;;AACA,QAAIkD,SAASlD,IAAIiD,KAAjB;AACA,QAAI,EAAEC,kBAAkBvB,KAApB,CAAJ,EACE,MAAM1C,eAAe,wBAAf,EAAyC;AAAE4B;AAAF,KAAzC,CAAN;AACFvC,6BAAyB4E,MAAzB,EAlBmC,CAoBnC;;AACA,QAAIC,WAAW3B,SAAf;;AACA,QAAI,eAAexB,GAAnB,EAAwB;AACtB,UAAI,OAAOA,IAAIoD,SAAX,KAAyB,QAA7B,EACE,MAAMnE,eAAe,mCAAf,EAAoD;AAAE4B;AAAF,OAApD,CAAN,CAFoB,CAGtB;;AACA,UAAIb,IAAIoD,SAAJ,GAAgB,CAApB,EACE,MAAMnE,eACJ,6CADI,EAC2C;AAAE4B;AAAF,OAD3C,CAAN;AAEFsC,iBAAWnD,IAAIoD,SAAf;AACD,KA9BkC,CAgCnC;;;AACA,QAAIC,QAAQ7B,SAAZ;;AACA,QAAI,YAAYxB,GAAhB,EAAqB;AACnB,UAAI,OAAOA,IAAIsD,MAAX,KAAsB,QAA1B,EACE,MAAMrE,eAAe,gCAAf,EAAiD;AAAE4B;AAAF,OAAjD,CAAN,CAFiB,CAGnB;;AACA,UAAIb,IAAIsD,MAAJ,GAAa,CAAjB,EACE,MAAMrE,eACJ,0CADI,EACwC;AAAE4B;AAAF,OADxC,CAAN;AAEFwC,cAAQrD,IAAIsD,MAAZ;AACD,KA1CkC,CA4CnC;;;AACA,QAAIC,eAAe/B,SAAnB;;AACA,QAAIxB,IAAIwD,KAAR,EAAe;AACb,UAAIH,UAAU7B,SAAd,EACE,MAAMvC,eAAe,qCAAf,EAAsD;AAAE4B;AAAF,OAAtD,CAAN,CAFW,CAGb;AACA;AACA;AACA;;AACA0C,qBAAe,IAAIE,UAAUC,MAAd,CAAqB1D,IAAIwD,KAAzB,EAAgCG,aAAhC,EAAf;;AACA,WAAK,IAAIzC,IAAI,CAAb,EAAgBA,IAAIgC,OAAO/B,MAA3B,EAAmCD,GAAnC,EAAwC;AACtC,YAAIvC,gBAAgBiF,EAAhB,CAAmBC,KAAnB,CAAyBX,OAAOhC,CAAP,CAAzB,MAAwC,CAA5C,EAA+C;AAC7C,gBAAMjC,eAAe,sCACT,oCADN,EAC4C;AAAE4B;AAAF,WAD5C,CAAN;AAED;AACF;AACF,KA5DkC,CA8DnC;;;AACA,QAAIsC,aAAa3B,SAAjB,EAA4B;AAC1B,WAAK,IAAIsC,IAAI,CAAb,EAAgBA,IAAIZ,OAAO/B,MAA3B,EAAmC2C,GAAnC;AACEpD,eAAOG,KAAP,EAAciB,IAAd,CAAmBoB,OAAOY,CAAP,CAAnB;AADF;AAED,KAHD,MAGO;AACL,UAAIC,kBAAkB,CAACZ,QAAD,EAAW,CAAX,CAAtB;;AACA,WAAK,IAAIW,IAAI,CAAb,EAAgBA,IAAIZ,OAAO/B,MAA3B,EAAmC2C,GAAnC;AACEC,wBAAgBjC,IAAhB,CAAqBoB,OAAOY,CAAP,CAArB;AADF;;AAEAnC,YAAMqC,SAAN,CAAgBC,MAAhB,CAAuBC,KAAvB,CAA6BxD,OAAOG,KAAP,CAA7B,EAA4CkD,eAA5C;AACD,KAvEkC,CAyEnC;;;AACA,QAAIR,YAAJ,EACE7C,OAAOG,KAAP,EAAcsD,IAAd,CAAmBZ,YAAnB,EA3EiC,CA6EnC;;AACA,QAAIF,UAAU7B,SAAd,EAAyB;AACvB,UAAI6B,UAAU,CAAd,EACE3C,OAAOG,KAAP,IAAgB,EAAhB,CADF,CACuB;AADvB,WAGEH,OAAOG,KAAP,IAAgBH,OAAOG,KAAP,EAAcwC,KAAd,CAAoBA,KAApB,CAAhB;AACH;AACF,GAzKa;AA0Kde,YAAU,UAAU1D,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACtC,QAAI,EAAE,QAAOA,GAAP,uDAAOA,GAAP,OAAe,QAAf,IAA2BA,eAAe2B,KAA5C,CAAJ,EACE,MAAM1C,eAAe,mDAAf,CAAN;AACFX,6BAAyB0B,GAAzB;AACA,QAAIqE,IAAI3D,OAAOG,KAAP,CAAR;AACA,QAAIwD,MAAM7C,SAAV,EACEd,OAAOG,KAAP,IAAgBb,GAAhB,CADF,KAEK,IAAI,EAAEqE,aAAa1C,KAAf,CAAJ,EACH,MAAM1C,eACJ,6CADI,EAC2C;AAAE4B;AAAF,KAD3C,CAAN,CADG,KAGA;AACH,WAAK,IAAIK,IAAI,CAAb,EAAgBA,IAAIlB,IAAImB,MAAxB,EAAgCD,GAAhC;AACEmD,UAAEvC,IAAF,CAAO9B,IAAIkB,CAAJ,CAAP;AADF;AAED;AACF,GAxLa;AAyLdoD,aAAW,UAAU5D,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACvC,QAAIuE,SAAS,KAAb;;AACA,QAAI,QAAOvE,GAAP,uDAAOA,GAAP,OAAe,QAAnB,EAA6B;AAC3B;AACA,UAAMe,OAAOyD,OAAOzD,IAAP,CAAYf,GAAZ,CAAb;;AACA,UAAIe,KAAK,CAAL,MAAY,OAAhB,EAAwB;AACtBwD,iBAAS,IAAT;AACD;AACF;;AACD,QAAIE,SAASF,SAASvE,IAAI,OAAJ,CAAT,GAAwB,CAACA,GAAD,CAArC;AACA1B,6BAAyBmG,MAAzB;AACA,QAAIJ,IAAI3D,OAAOG,KAAP,CAAR;AACA,QAAIwD,MAAM7C,SAAV,EACEd,OAAOG,KAAP,IAAgB4D,MAAhB,CADF,KAEK,IAAI,EAAEJ,aAAa1C,KAAf,CAAJ,EACH,MAAM1C,eACJ,8CADI,EAC4C;AAAE4B;AAAF,KAD5C,CAAN,CADG,KAGA;AACHpB,QAAEC,IAAF,CAAO+E,MAAP,EAAe,UAAUC,KAAV,EAAiB;AAC9B,aAAK,IAAIxD,IAAI,CAAb,EAAgBA,IAAImD,EAAElD,MAAtB,EAA8BD,GAA9B;AACE,cAAIvC,gBAAgBiF,EAAhB,CAAmBe,MAAnB,CAA0BD,KAA1B,EAAiCL,EAAEnD,CAAF,CAAjC,CAAJ,EACE;AAFJ;;AAGAmD,UAAEvC,IAAF,CAAO4C,KAAP;AACD,OALD;AAMD;AACF,GAlNa;AAmNdxC,QAAM,UAAUxB,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC,QAAIU,WAAWc,SAAf,EACE;AACF,QAAI6C,IAAI3D,OAAOG,KAAP,CAAR;AACA,QAAIwD,MAAM7C,SAAV,EACE,OADF,KAEK,IAAI,EAAE6C,aAAa1C,KAAf,CAAJ,EACH,MAAM1C,eACJ,yCADI,EACuC;AAAE4B;AAAF,KADvC,CAAN,CADG,KAGA;AACH,UAAI,OAAOb,GAAP,KAAe,QAAf,IAA2BA,MAAM,CAArC,EACEqE,EAAEJ,MAAF,CAAS,CAAT,EAAY,CAAZ,EADF,KAGEI,EAAEvD,GAAF;AACH;AACF,GAlOa;AAmOdsB,SAAO,UAAU1B,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACnC,QAAIU,WAAWc,SAAf,EACE;AACF,QAAI6C,IAAI3D,OAAOG,KAAP,CAAR;AACA,QAAIwD,MAAM7C,SAAV,EACE,OADF,KAEK,IAAI,EAAE6C,aAAa1C,KAAf,CAAJ,EACH,MAAM1C,eACJ,kDADI,EACgD;AAAE4B;AAAF,KADhD,CAAN,CADG,KAGA;AACH,UAAI+D,MAAM,EAAV;;AACA,UAAI5E,OAAO,IAAP,IAAe,QAAOA,GAAP,uDAAOA,GAAP,OAAe,QAA9B,IAA0C,EAAEA,eAAe2B,KAAjB,CAA9C,EAAuE;AACrE;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA,YAAIkD,UAAU,IAAIpB,UAAUqB,OAAd,CAAsB9E,GAAtB,CAAd;;AACA,aAAK,IAAIkB,IAAI,CAAb,EAAgBA,IAAImD,EAAElD,MAAtB,EAA8BD,GAA9B;AACE,cAAI,CAAC2D,QAAQE,eAAR,CAAwBV,EAAEnD,CAAF,CAAxB,EAA8B8D,MAAnC,EACEJ,IAAI9C,IAAJ,CAASuC,EAAEnD,CAAF,CAAT;AAFJ;AAGD,OAdD,MAcO;AACL,aAAK,IAAIA,IAAI,CAAb,EAAgBA,IAAImD,EAAElD,MAAtB,EAA8BD,GAA9B;AACE,cAAI,CAACvC,gBAAgBiF,EAAhB,CAAmBe,MAAnB,CAA0BN,EAAEnD,CAAF,CAA1B,EAAgClB,GAAhC,CAAL,EACE4E,IAAI9C,IAAJ,CAASuC,EAAEnD,CAAF,CAAT;AAFJ;AAGD;;AACDR,aAAOG,KAAP,IAAgB+D,GAAhB;AACD;AACF,GAnQa;AAoQdvC,YAAU,UAAU3B,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AACtC,QAAI,EAAE,QAAOA,GAAP,uDAAOA,GAAP,OAAe,QAAf,IAA2BA,eAAe2B,KAA5C,CAAJ,EACE,MAAM1C,eACJ,mDADI,EACiD;AAAE4B;AAAF,KADjD,CAAN;AAEF,QAAIH,WAAWc,SAAf,EACE;AACF,QAAI6C,IAAI3D,OAAOG,KAAP,CAAR;AACA,QAAIwD,MAAM7C,SAAV,EACE,OADF,KAEK,IAAI,EAAE6C,aAAa1C,KAAf,CAAJ,EACH,MAAM1C,eACJ,kDADI,EACgD;AAAE4B;AAAF,KADhD,CAAN,CADG,KAGA;AACH,UAAI+D,MAAM,EAAV;;AACA,WAAK,IAAI1D,IAAI,CAAb,EAAgBA,IAAImD,EAAElD,MAAtB,EAA8BD,GAA9B,EAAmC;AACjC,YAAI+D,UAAU,KAAd;;AACA,aAAK,IAAInB,IAAI,CAAb,EAAgBA,IAAI9D,IAAImB,MAAxB,EAAgC2C,GAAhC,EAAqC;AACnC,cAAInF,gBAAgBiF,EAAhB,CAAmBe,MAAnB,CAA0BN,EAAEnD,CAAF,CAA1B,EAAgClB,IAAI8D,CAAJ,CAAhC,CAAJ,EAA6C;AAC3CmB,sBAAU,IAAV;AACA;AACD;AACF;;AACD,YAAI,CAACA,OAAL,EACEL,IAAI9C,IAAJ,CAASuC,EAAEnD,CAAF,CAAT;AACH;;AACDR,aAAOG,KAAP,IAAgB+D,GAAhB;AACD;AACF,GA/Ra;AAgSdzC,WAAS,UAAUzB,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8BC,OAA9B,EAAuCpB,GAAvC,EAA4C;AACnD,QAAIoB,YAAYD,GAAhB,EACE;AACA,YAAMf,eAAe,wCAAf,EAAyD;AAAE4B;AAAF,OAAzD,CAAN;AACF,QAAIH,WAAW,IAAf,EACE,MAAMzB,eAAe,8BAAf,EAA+C;AAAE4B;AAAF,KAA/C,CAAN;AACF,QAAI,OAAOb,GAAP,KAAe,QAAnB,EACE,MAAMf,eAAe,iCAAf,EAAkD;AAAE4B;AAAF,KAAlD,CAAN;;AACF,QAAIb,IAAIkF,OAAJ,CAAY,IAAZ,IAAoB,CAAC,CAAzB,EAA4B;AAC1B;AACA;AACA,YAAMjG,eACJ,iEADI,EAEJ;AAAE4B;AAAF,OAFI,CAAN;AAGD;;AACD,QAAIH,WAAWc,SAAf,EACE;AACF,QAAI9C,IAAIgC,OAAOG,KAAP,CAAR;AACA,WAAOH,OAAOG,KAAP,CAAP;AAEA,QAAIX,WAAWF,IAAIG,KAAJ,CAAU,GAAV,CAAf;AACA,QAAIgF,UAAUxE,cAAc9B,GAAd,EAAmBqB,QAAnB,EAA6B;AAACO,mBAAa;AAAd,KAA7B,CAAd;AACA,QAAI0E,YAAY,IAAhB,EACE,MAAMlG,eAAe,8BAAf,EAA+C;AAAE4B;AAAF,KAA/C,CAAN;AACF,QAAIuE,SAASlF,SAASY,GAAT,EAAb;AACAqE,YAAQC,MAAR,IAAkB1G,CAAlB;AACD,GA1Ta;AA2Td2G,QAAM,UAAU3E,MAAV,EAAkBG,KAAlB,EAAyBb,GAAzB,EAA8B;AAClC;AACA;AACA,UAAMf,eAAe,uBAAf,EAAwC;AAAE4B;AAAF,KAAxC,CAAN;AACD;AA/Ta,CAAhB","file":"/packages/minimongo/modify.js.map","sourcesContent":["import { assertHasValidFieldNames, assertIsValidFieldName } from './validation.js';\n\n// XXX need a strategy for passing the binding of $ into this\n// function, from the compiled selector\n//\n// maybe just {key.up.to.just.before.dollarsign: array_index}\n//\n// XXX atomicity: if one modification fails, do we roll back the whole\n// change?\n//\n// options:\n//   - isInsert is set when _modify is being called to compute the document to\n//     insert as part of an upsert operation. We use this primarily to figure\n//     out when to set the fields in $setOnInsert, if present.\nLocalCollection._modify = function (doc, mod, options) {\n  options = options || {};\n  if (!isPlainObject(mod))\n    throw MinimongoError(\"Modifier must be an object\");\n\n  // Make sure the caller can't mutate our data structures.\n  mod = EJSON.clone(mod);\n\n  var isModifier = isOperatorObject(mod);\n\n  var newDoc;\n\n  if (!isModifier) {\n    if (mod._id && !EJSON.equals(doc._id, mod._id))\n      throw MinimongoError(\"Cannot change the _id of a document\");\n\n    // replace the whole document\n    assertHasValidFieldNames(mod);\n    newDoc = mod;\n  } else {\n    // apply modifiers to the doc.\n    newDoc = EJSON.clone(doc);\n\n    _.each(mod, function (operand, op) {\n      var modFunc = MODIFIERS[op];\n      // Treat $setOnInsert as $set if this is an insert.\n      if (options.isInsert && op === '$setOnInsert')\n        modFunc = MODIFIERS['$set'];\n      if (!modFunc)\n        throw MinimongoError(\"Invalid modifier specified \" + op);\n      _.each(operand, function (arg, keypath) {\n        if (keypath === '') {\n          throw MinimongoError(\"An empty update path is not valid.\");\n        }\n\n        if (keypath === '_id' && op !== '$setOnInsert') {\n          throw MinimongoError(\"Mod on _id not allowed\");\n        }\n\n        var keyparts = keypath.split('.');\n\n        if (! _.all(keyparts, _.identity)) {\n          throw MinimongoError(\n            \"The update path '\" + keypath +\n              \"' contains an empty field name, which is not allowed.\");\n        }\n\n        var noCreate = _.has(NO_CREATE_MODIFIERS, op);\n        var forbidArray = (op === \"$rename\");\n        var target = findModTarget(newDoc, keyparts, {\n          noCreate: NO_CREATE_MODIFIERS[op],\n          forbidArray: (op === \"$rename\"),\n          arrayIndices: options.arrayIndices\n        });\n        var field = keyparts.pop();\n        modFunc(target, field, arg, keypath, newDoc);\n      });\n    });\n  }\n\n  // move new document into place.\n  _.each(_.keys(doc), function (k) {\n    // Note: this used to be for (var k in doc) however, this does not\n    // work right in Opera. Deleting from a doc while iterating over it\n    // would sometimes cause opera to skip some keys.\n    if (k !== '_id')\n      delete doc[k];\n  });\n  _.each(newDoc, function (v, k) {\n    doc[k] = v;\n  });\n};\n\n// for a.b.c.2.d.e, keyparts should be ['a', 'b', 'c', '2', 'd', 'e'],\n// and then you would operate on the 'e' property of the returned\n// object.\n//\n// if options.noCreate is falsey, creates intermediate levels of\n// structure as necessary, like mkdir -p (and raises an exception if\n// that would mean giving a non-numeric property to an array.) if\n// options.noCreate is true, return undefined instead.\n//\n// may modify the last element of keyparts to signal to the caller that it needs\n// to use a different value to index into the returned object (for example,\n// ['a', '01'] -> ['a', 1]).\n//\n// if forbidArray is true, return null if the keypath goes through an array.\n//\n// if options.arrayIndices is set, use its first element for the (first) '$' in\n// the path.\nvar findModTarget = function (doc, keyparts, options) {\n  options = options || {};\n  var usedArrayIndex = false;\n  for (var i = 0; i < keyparts.length; i++) {\n    var last = (i === keyparts.length - 1);\n    var keypart = keyparts[i];\n    var indexable = isIndexable(doc);\n    if (!indexable) {\n      if (options.noCreate)\n        return undefined;\n      var e = MinimongoError(\n        \"cannot use the part '\" + keypart + \"' to traverse \" + doc);\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (doc instanceof Array) {\n      if (options.forbidArray)\n        return null;\n      if (keypart === '$') {\n        if (usedArrayIndex)\n          throw MinimongoError(\"Too many positional (i.e. '$') elements\");\n        if (!options.arrayIndices || !options.arrayIndices.length) {\n          throw MinimongoError(\"The positional operator did not find the \" +\n                               \"match needed from the query\");\n        }\n        keypart = options.arrayIndices[0];\n        usedArrayIndex = true;\n      } else if (isNumericKey(keypart)) {\n        keypart = parseInt(keypart);\n      } else {\n        if (options.noCreate)\n          return undefined;\n        throw MinimongoError(\n          \"can't append to array using string field name [\"\n                    + keypart + \"]\");\n      }\n      if (last)\n        // handle 'a.01'\n        keyparts[i] = keypart;\n      if (options.noCreate && keypart >= doc.length)\n        return undefined;\n      while (doc.length < keypart)\n        doc.push(null);\n      if (!last) {\n        if (doc.length === keypart)\n          doc.push({});\n        else if (typeof doc[keypart] !== \"object\")\n          throw MinimongoError(\"can't modify field '\" + keyparts[i + 1] +\n                      \"' of list value \" + JSON.stringify(doc[keypart]));\n      }\n    } else {\n      assertIsValidFieldName(keypart);\n      if (!(keypart in doc)) {\n        if (options.noCreate)\n          return undefined;\n        if (!last)\n          doc[keypart] = {};\n      }\n    }\n\n    if (last)\n      return doc;\n    doc = doc[keypart];\n  }\n\n  // notreached\n};\n\nvar NO_CREATE_MODIFIERS = {\n  $unset: true,\n  $pop: true,\n  $rename: true,\n  $pull: true,\n  $pullAll: true\n};\n\nvar MODIFIERS = {\n  $currentDate: function (target, field, arg) {\n    if (typeof arg === \"object\" && arg.hasOwnProperty(\"$type\")) {\n       if (arg.$type !== \"date\") {\n          throw MinimongoError(\n            \"Minimongo does currently only support the date type \" +\n            \"in $currentDate modifiers\",\n            { field });\n       }\n    } else if (arg !== true) {\n      throw MinimongoError(\"Invalid $currentDate modifier\", { field });\n    }\n    target[field] = new Date();\n  },\n  $min: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $min allowed for numbers only\", { field });\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\n          \"Cannot apply $min modifier to non-number\", { field });\n      }\n      if (target[field] > arg) {\n        target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $max: function (target, field, arg) {\n    if (typeof arg !== \"number\") {\n      throw MinimongoError(\"Modifier $max allowed for numbers only\", { field });\n    }\n    if (field in target) {\n      if (typeof target[field] !== \"number\") {\n        throw MinimongoError(\n          \"Cannot apply $max modifier to non-number\", { field });\n      }\n      if (target[field] < arg) {\n         target[field] = arg;\n      }\n    } else {\n      target[field] = arg;\n    }\n  },\n  $inc: function (target, field, arg) {\n    if (typeof arg !== \"number\")\n      throw MinimongoError(\"Modifier $inc allowed for numbers only\", { field });\n    if (field in target) {\n      if (typeof target[field] !== \"number\")\n        throw MinimongoError(\n          \"Cannot apply $inc modifier to non-number\", { field });\n      target[field] += arg;\n    } else {\n      target[field] = arg;\n    }\n  },\n  $set: function (target, field, arg) {\n    if (!_.isObject(target)) { // not an array or an object\n      var e = MinimongoError(\n        \"Cannot set property on non-object field\", { field });\n      e.setPropertyError = true;\n      throw e;\n    }\n    if (target === null) {\n      var e = MinimongoError(\"Cannot set property on null\", { field });\n      e.setPropertyError = true;\n      throw e;\n    }\n    assertHasValidFieldNames(arg);\n    target[field] = arg;\n  },\n  $setOnInsert: function (target, field, arg) {\n    // converted to `$set` in `_modify`\n  },\n  $unset: function (target, field, arg) {\n    if (target !== undefined) {\n      if (target instanceof Array) {\n        if (field in target)\n          target[field] = null;\n      } else\n        delete target[field];\n    }\n  },\n  $push: function (target, field, arg) {\n    if (target[field] === undefined)\n      target[field] = [];\n    if (!(target[field] instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $push modifier to non-array\", { field });\n\n    if (!(arg && arg.$each)) {\n      // Simple mode: not $each\n      assertHasValidFieldNames(arg);\n      target[field].push(arg);\n      return;\n    }\n\n    // Fancy mode: $each (and maybe $slice and $sort and $position)\n    var toPush = arg.$each;\n    if (!(toPush instanceof Array))\n      throw MinimongoError(\"$each must be an array\", { field });\n    assertHasValidFieldNames(toPush);\n\n    // Parse $position\n    var position = undefined;\n    if ('$position' in arg) {\n      if (typeof arg.$position !== \"number\")\n        throw MinimongoError(\"$position must be a numeric value\", { field });\n      // XXX should check to make sure integer\n      if (arg.$position < 0)\n        throw MinimongoError(\n          \"$position in $push must be zero or positive\", { field });\n      position = arg.$position;\n    }\n\n    // Parse $slice.\n    var slice = undefined;\n    if ('$slice' in arg) {\n      if (typeof arg.$slice !== \"number\")\n        throw MinimongoError(\"$slice must be a numeric value\", { field });\n      // XXX should check to make sure integer\n      if (arg.$slice > 0)\n        throw MinimongoError(\n          \"$slice in $push must be zero or negative\", { field });\n      slice = arg.$slice;\n    }\n\n    // Parse $sort.\n    var sortFunction = undefined;\n    if (arg.$sort) {\n      if (slice === undefined)\n        throw MinimongoError(\"$sort requires $slice to be present\", { field });\n      // XXX this allows us to use a $sort whose value is an array, but that's\n      // actually an extension of the Node driver, so it won't work\n      // server-side. Could be confusing!\n      // XXX is it correct that we don't do geo-stuff here?\n      sortFunction = new Minimongo.Sorter(arg.$sort).getComparator();\n      for (var i = 0; i < toPush.length; i++) {\n        if (LocalCollection._f._type(toPush[i]) !== 3) {\n          throw MinimongoError(\"$push like modifiers using $sort \" +\n                      \"require all elements to be objects\", { field });\n        }\n      }\n    }\n\n    // Actually push.\n    if (position === undefined) {\n      for (var j = 0; j < toPush.length; j++)\n        target[field].push(toPush[j]);\n    } else {\n      var spliceArguments = [position, 0];\n      for (var j = 0; j < toPush.length; j++)\n        spliceArguments.push(toPush[j]);\n      Array.prototype.splice.apply(target[field], spliceArguments);\n    }\n\n    // Actually sort.\n    if (sortFunction)\n      target[field].sort(sortFunction);\n\n    // Actually slice.\n    if (slice !== undefined) {\n      if (slice === 0)\n        target[field] = [];  // differs from Array.slice!\n      else\n        target[field] = target[field].slice(slice);\n    }\n  },\n  $pushAll: function (target, field, arg) {\n    if (!(typeof arg === \"object\" && arg instanceof Array))\n      throw MinimongoError(\"Modifier $pushAll/pullAll allowed for arrays only\");\n    assertHasValidFieldNames(arg);\n    var x = target[field];\n    if (x === undefined)\n      target[field] = arg;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $pushAll modifier to non-array\", { field });\n    else {\n      for (var i = 0; i < arg.length; i++)\n        x.push(arg[i]);\n    }\n  },\n  $addToSet: function (target, field, arg) {\n    var isEach = false;\n    if (typeof arg === \"object\") {\n      //check if first key is '$each'\n      const keys = Object.keys(arg);\n      if (keys[0] === \"$each\"){\n        isEach = true;\n      }\n    }\n    var values = isEach ? arg[\"$each\"] : [arg];\n    assertHasValidFieldNames(values);\n    var x = target[field];\n    if (x === undefined)\n      target[field] = values;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $addToSet modifier to non-array\", { field });\n    else {\n      _.each(values, function (value) {\n        for (var i = 0; i < x.length; i++)\n          if (LocalCollection._f._equal(value, x[i]))\n            return;\n        x.push(value);\n      });\n    }\n  },\n  $pop: function (target, field, arg) {\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $pop modifier to non-array\", { field });\n    else {\n      if (typeof arg === 'number' && arg < 0)\n        x.splice(0, 1);\n      else\n        x.pop();\n    }\n  },\n  $pull: function (target, field, arg) {\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $pull/pullAll modifier to non-array\", { field });\n    else {\n      var out = [];\n      if (arg != null && typeof arg === \"object\" && !(arg instanceof Array)) {\n        // XXX would be much nicer to compile this once, rather than\n        // for each document we modify.. but usually we're not\n        // modifying that many documents, so we'll let it slide for\n        // now\n\n        // XXX Minimongo.Matcher isn't up for the job, because we need\n        // to permit stuff like {$pull: {a: {$gt: 4}}}.. something\n        // like {$gt: 4} is not normally a complete selector.\n        // same issue as $elemMatch possibly?\n        var matcher = new Minimongo.Matcher(arg);\n        for (var i = 0; i < x.length; i++)\n          if (!matcher.documentMatches(x[i]).result)\n            out.push(x[i]);\n      } else {\n        for (var i = 0; i < x.length; i++)\n          if (!LocalCollection._f._equal(x[i], arg))\n            out.push(x[i]);\n      }\n      target[field] = out;\n    }\n  },\n  $pullAll: function (target, field, arg) {\n    if (!(typeof arg === \"object\" && arg instanceof Array))\n      throw MinimongoError(\n        \"Modifier $pushAll/pullAll allowed for arrays only\", { field });\n    if (target === undefined)\n      return;\n    var x = target[field];\n    if (x === undefined)\n      return;\n    else if (!(x instanceof Array))\n      throw MinimongoError(\n        \"Cannot apply $pull/pullAll modifier to non-array\", { field });\n    else {\n      var out = [];\n      for (var i = 0; i < x.length; i++) {\n        var exclude = false;\n        for (var j = 0; j < arg.length; j++) {\n          if (LocalCollection._f._equal(x[i], arg[j])) {\n            exclude = true;\n            break;\n          }\n        }\n        if (!exclude)\n          out.push(x[i]);\n      }\n      target[field] = out;\n    }\n  },\n  $rename: function (target, field, arg, keypath, doc) {\n    if (keypath === arg)\n      // no idea why mongo has this restriction..\n      throw MinimongoError(\"$rename source must differ from target\", { field });\n    if (target === null)\n      throw MinimongoError(\"$rename source field invalid\", { field });\n    if (typeof arg !== \"string\")\n      throw MinimongoError(\"$rename target must be a string\", { field });\n    if (arg.indexOf('\\0') > -1) {\n      // Null bytes are not allowed in Mongo field names\n      // https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names\n      throw MinimongoError(\n        \"The 'to' field for $rename cannot contain an embedded null byte\",\n        { field });\n    }\n    if (target === undefined)\n      return;\n    var v = target[field];\n    delete target[field];\n\n    var keyparts = arg.split('.');\n    var target2 = findModTarget(doc, keyparts, {forbidArray: true});\n    if (target2 === null)\n      throw MinimongoError(\"$rename target field invalid\", { field });\n    var field2 = keyparts.pop();\n    target2[field2] = v;\n  },\n  $bit: function (target, field, arg) {\n    // XXX mongo only supports $bit on integers, and we only support\n    // native javascript numbers (doubles) so far, so we can't support $bit\n    throw MinimongoError(\"$bit is not supported\", { field });\n  }\n};\n"]},"hash":"cc19766693a4d0ff97dcba03f08a4920c52d4313"}
